#library "strnghld"
#include "zcommon.acs"

//////////////////////////////////////////////////////////////////
// SHOP SYSTEM by Cutmanmike /////////////////////////////////////
// [optimised by Jimmy]		 /////////////////////////////////////
//////////////////////////////////////////////////////////////////

#define MAX_SHOPITEMS 27

#define SHOP_INVALID			0
#define SHOP_RANDOMWEAPON		1
#define SHOP_BARRIERKIT			2
#define SHOP_QUADDAMAGE			3
#define SHOP_CHRONOSPHERE		4
#define SHOP_SENTRYUNIT			5
#define SHOP_BARREL				6
#define SHOP_MARINE				7
#define SHOP_INVULNERABILITY	8
#define SHOP_PORTABLEMEDKIT		9
#define SHOP_PORTABLESUPERKIT	10
#define SHOP_GREENARMOR			11
#define SHOP_BLUEARMOR			12
#define SHOP_SUPERSHIELD		13
#define SHOP_MAXHEALTHBONUS		14
#define SHOP_MAXARMORBONUS		15
#define SHOP_SMARTBOMB			16
#define SHOP_AUTODRONE			17
#define SHOP_EXTRALIFE			18
#define SHOP_REGENERATION		19
#define SHOP_PROTECTION			20
#define SHOP_VAMPIRISM			21
#define SHOP_MORPHDEVICE		22
#define SHOP_IWINBUTTON			23
#define SHOP_WEAPONUPGRADEKIT	24
#define SHOP_ELITEMARINE		25
#define SHOP_SUPERSENTRYUNIT	26

str Shop[MAX_SHOPITEMS][3] =
{
	{},
	{
		"Random Weapon Device","RandomWeaponItem",
		"   The Random Weapon Device (or RWD for short) provides you
		\n   with a randomly selected but powerful weapon, along with
		\n   enough ammo to take out a wide variety of hellspawn. Use
		\n   almost as soon as you can!",
	},
	{
		"Barrier Kit","WallItem",
		"   The Barrier Kit creates a horizontal wall of red energy
		\n   directly in front of you when used. This wall stays for a
		\n   limited time and blocks even the largest of demons. But
		\n   use it sparingly: it can be destroyed!",
	},
	{
		"Quad Damage","QuadDamageItem",
		"   As the name implies, it quadruples the damage dealt by all
		\n   your weaponry. It lasts for several seconds and can be used
		\n   on both large waves in open warfare and small waves in
		\n   close combat.",
	},
	{
		"Chronosphere Device","TimeFreezerItem",
		"   In case you're running short on time, the chronosphere
		\n   device will freeze time temporarily. The UAC worked
		\n   painstakingly hard on this extremely potent powerup, so
		\n   it won't come cheap."
	},
	{
		"Sentry Unit","SentryItem",
		"   The sentry drone is a portable defense turret that can
		\n   be placed almost anywhere. Be sure to place it in an
		\n   advantageous position, because it can't move on its own."
	},
	{
		"Barrel Spawner","BarrelItem",
		"   A marine's favorite - these lethally volatile barrels
		\n   of radioactive ooze will damage anything within a
		\n   considerable blast radius when struck."
	},
	{
		"Marine Reinforcements","MarineItem",
		"   Use this powerup to summon a fellow marine to fight
		\n   alongside you shoulder to shoulder, until they die in
		\n   combat. They are usually kitted with shotguns and
		\n   chainguns, but with a little luck you'll receive one
		\n   with a devastating plasma rifle."
	},
	{
		"Invulnerability","InvulnerabilityItem",
		"   This portable energy field will make you immune to
		\n   all damage, hence becoming totally invulnerable for
		\n   thirty seconds, during which you must lay out as
		\n   much hurt to the enemy as possible."
	},
	{
		"Portable Medkit","PMedkit",
		"   The portable medikit instantly heals you by 25%, up to
		\n   your maximum health. Convenient if you need a quick
		\n   pick-me-up, but for body enhancements to increase your
		\n   max health, visit the UAC Cybernetic Industries shop!"
	},
	{
		"Portable Super Medkit","PSuperMedkit",
		"   The portable super medikit immediately heals up to 100
		\n   health points, but won't heal you in excess of your
		\n   maximum health. Visit the UAC Cybernetic Industries
		\n   shop for other useful body enhancements!"
	},
	{
		"Green Armor","GreenArmor",
		"   It's not much, but it protects you from roughly a
		\n   third of damage done to you, and boosts your armor
		\n   to 100 points. Suited more to open warfare against
		\n   less powerful demons."
	},
	{
		"Blue Armor","BlueArmor",
		"   A much stronger variety of body armor, giving you
		\n   a maximum of 200 armor points. Be sure you have
		\n   enough health before using it - or you'll end up
		\n   with a super-strong armor suit... and dead."
	},
	{
		"Super Shield","SuperShield",
		"   The ultimate in body armor, the Super Shield cranks your
		\n   armor up to 300%, and, rather than reduces damage to your
		\n   body, absorbs it completely. As long as the super shield
		\n   is active, you won't lose health at all."
	},
	{
		"Max Health Enhancement","MaxHealthBonus2",
		"   Adds 5 points to your maximum amount of health, allowing
		\n   you to heal yourself with medikits to above 100%."
	},
	{
		"Max Armor Enhancement","MaxArmorBonus2",
		"   Adds 5 points to your maximum amount of armor,
		\n   causing armor powerups to boost you above 100%."
	},
	{
		"Smart Bomb","SmartBombItem",
		"   Expensive, rare, deadly. Throw a Smart Bomb into the
		\n   midst of a large group of demons, get behind something,
		\n   and wait for the blast to utterly destroy, or at the
		\n   very least severely damage, anything in its range."
	},
	{
		"Auto Drone","AutoDroneItem",
		"   The auto drone follows its host and attacks enemies
		\n   with a powerful antimatter cannon for as long as its
		\n   short life lasts. Great for extra support, plus two
		\n   can be utilized at once!"
	},
	{
		"Extra Life","LifeItem",
		"   Killed in action? No problem! The UAC has developed this
		\n   special bio-supplement to recover your remains, regenerate
		\n   your body and send you right back onto the battlefield with-
		\n   out a scratch. While very useful, extras won't come cheap."
	},
	{
		"Regeneration","RegenerationItem",
		"   This item slowly seals your wounds and other ailments
		\n   until you return to your maximum health, or until it
		\n   runs out. Very useful when health is in short supply
		\n   between waves."
	},
	{
		"Protection","ProtectionItem",
		"   This little miracle works great when you're up against
		\n   the most powerful demons. For a limited time, it absorbs
		\n   3/4 of the damage you'd normally take, and can be used in
		\n   conjunction with both types of regular armor for extra
		\n   damage reduction."
	},
	{
		"Vampirism","DrainItem",
		"   While this item is active, you can turn half the
		\n   damage you dish out into health for you, up to your
		\n   maximum health value. The more pain you inflict, the
		\n   faster you are healed. No medkits? No sweat."
	},
	{
		"Morph Device","MorphPlayerItem",
		"   Ever wondered what it's like to be a demon? Now you can
		\n   find out. With this item, one of the UAC's finest scientific
		\n   achievements, you can turn yourself into a Bruiser Demon,
		\n   and have access to all of its strengths, weaknesses, and -
		\n   best of all - attacks."
	},
	/*{
		"Terminator Mech","MorphPlayerItem2",
		"   The UAC technology experts were able to create a replica of
		\n   the terminator mech, complete with attacks, for the Marine's
		\n   side. Sadly, we arent't able to replicate the Terminator's
		\n   defensive forcefield, so you'll won't be quite as durable as
		\n   the original Terminator. It's expensive, but worth it."
	},*/
	{
		"I Win Button","IWinButtonItem",
		"   This amazing utility augments your arsenal and body in
		\n   countless different ways, allowing you to wreak havoc on
		\n   your foes for a few glorious seconds, during which your
		\n   strength can only be compared to that of a God. Believe us,
		\n   this elusive item is worth every penny."
	},
	{
		"Weapon Powerup Kit","WeaponPowerItem",
		"   This incredible powerup kit is packed with countless
		\n   useful components with which to augment your armory.
		\n   When utilized, it will boost your weapons' destructive
		\n   capacity for a short time."
	},
	{
		"Elite Marine Reinforcements", "SuperMarineItem",
		"   Summons our most well trained men to fight alongside you in
		\n   battle. These marines have spilled much demon blood in their
		\n   lifetime and are equipped with state-of-the-art weaponry."
	},
	{
		"Super Sentry Unit", "SuperSentryItem",
		"   An upgrade to our best selling item. Besides a faster rate
		\n   of fire and more powerful artillery, this turret is
		\n   completely indestructable."
	},
};

int ShopItemCosts[MAX_SHOPITEMS][2] =
{
	{0,0},{300,5},{200,3},{500,3},{750,3},
	{300,3},{25,5},{100,5},{400,3},{50,10},
	{200,10},{50,99},{150,99},{500,99},{25,40},
	{25,40},{500,1},{300,2},{1250,9},{500,3},
	{300,3},{600,3},{1000,2},{5000,1},{1500,1},
	{600,0},{1000,0}
};

int PlayerConfirm[32];

// Hopefully Cutmanmike doesn't mind me simplifying his shop script. :P
// - Jimmy
script "Shop"(int shopitem)
{
	SetHudSize(640,480,0);
	if(!PlayerConfirm[PlayerNumber()])
	{
		// Print the description to the screen.
		HudMessage(s:"\cg",s:Shop[shopitem][0],s:"  \cf($",d:ShopItemCosts[shopitem][0],s:")\n",
			s:Shop[shopitem][2];
			HUDMSG_FADEINOUT,998,CR_UNTRANSLATED,230.0,30.0,12.0,0.3,0.3);
		ACS_ExecuteAlways(4,0);
	}
	else
	{
		// Check if the player has the sufficient number of credits.
		if(CheckInventory("CoinItem")<ShopItemCosts[shopitem][0])
		{
			HudMessage(s:"You do not have enough \cgcoins \clto buy this item!";
				HUDMSG_FADEINOUT,998,CR_UNTRANSLATED,230.4,30.0,1.5,0.3,0.3);
			LocalAmbientSound("No",128);
			PlayerConfirm[PlayerNumber()] = 0;
		}
		// Check if the player has the max amount of this item.
		else if(CheckInventory(Shop[shopitem][1])>=ShopItemCosts[shopitem][1])
		{
			HudMessage(s:"You already have the \cgmaximum amount \clof this item!";
				HUDMSG_FADEINOUT,998,CR_UNTRANSLATED,230.4,30.0,1.5,0.3,0.3);
			LocalAmbientSound("No",128);
			PlayerConfirm[PlayerNumber()] = 0;
		}
		// Just added this check into the new system: warn the play if he has no lives left.
		// (And forbid him from buying anything except lives until he has at least one.)
		else if(!CheckInventory("LifeItem") && shopitem!=18)
		{
			HudMessage(s:"You have \cgno lives \clleft!\n\nBuy an \cgextra life or two \clbefore you buy anything else!";
				HUDMSG_FADEINOUT,998,CR_UNTRANSLATED,230.4,30.0,3.5,0.3,0.3);
			LocalAmbientSound("No",128);
			PlayerConfirm[PlayerNumber()] = 0;
		}
		else
		{
			// Buy the item!
			int shopamount=1;
			// Check if it's a max health bonus the player is buying.
			if(shopitem==SHOP_MAXHEALTHBONUS)
				shopamount = 5;
			GiveInventory(Shop[shopitem][1],shopamount);
			TakeInventory("CoinItem",ShopItemCosts[shopitem][0]);
			HudMessage(s:"Thank you!"; HUDMSG_FADEINOUT,998,CR_UNTRANSLATED,230.4,30.0,1.5,0.3,0.3);
			LocalAmbientSound("Cash",128);
			PlayerConfirm[PlayerNumber()] = 0;
			delay(1);
		}
	}
}

script 4(void)
{
	PlayerConfirm[PlayerNumber()] = 1;
	SetPlayerProperty(0,1,PROP_TOTALLYFROZEN);
	delay(35);
	SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
	PlayerConfirm[PlayerNumber()] = 0;
}

str mapinfo[56][8] =
{
	{
		"Training Mission","Mars","Introduction","Deadline (Intro)","4","none","P_STR01",
		"Welcome to the training course. Here you will be pitted against holographic
		\nrenditions of Hell's weakest minions to get a taste of what awaits on the
		\nreal battlefields. Don't be afraid, the holo-demons aren't able to harm you.
		\nLt. Carmack will give you further briefing on the premise of deadline defense."
	},
	{
		"Tier 1, Mission 1","Mars","Too Young to Defend","Deadline","10","$100","P_STR02",
		"This will be your first major stronghold defense mission, marine. Here
		\nyou'll encounter the weakest of hell's forces, but that doesn't mean you
		\nwon't still have to be on your toes at all times - the difficulty mounts
		\nrapidly, so put all you've learned in training to the test!"
	},
	{
		"Tier 1, Mission 2","Sigma Two","Swamp","Deadline","10","$200","P_STR03",
		"The acidic lakes surrounding the perimeter of our strongholds on this planet are
		\nbathing holes for demons. Expect the demon numbers to be high and the task of
		\nsuccessfully defending this stronghold to be taxing for the amateur defender.
		\nAnd be sure not to plummet into the acid."
	},
	{
		"Tier 1, Mission 3","Maelstrom","Asteroid","Deadline","10","$300","P_STR04",
		"This volatile nebula houses a single UAC stronghold. Even so, it's a crucial research
		\noutpost, and its scientists wish to study the unique phenomena that occur within
		\nthis maelstrom. Research that could revolutionize UAC gateway technology is being
		\nconducted here, so it is vital that this facility doesn't fall to the legions of Hell."
	},
	{
		"Tier 1, Mission 4","Crimson","Twilight","Deadline","10","$400","P_STR05",
		"This dark mountain peak is home to a minute UAC stronghold. Demons are approaching from
		\nthe planet's ground level from all directions, and aerial assaults from steadily growing
		\ndemonic swarms are to be expected. It will be easy to let even the weakest demon cross the
		\ndeadline, so you'll have to secure the stronghold entrance as tightly as possible."
	},
	{
		"Tier 1, Mission 5","Earth","Downtown","Core (Intro)","10","$500","P_STR06",
		"Our beloved homeworld is rarely safe from demon invasion, especially one on a galactic
		\nscale. Possessed humans, now slaves to the demonic empire of Hell, roam our streets,
		\nlaying out a swath of destruction, while Hell sends out its heavy militia towards a
		\ncrucial UAC control point - a computer core station. Defend it with your life!"
	},
	{
		"Tier 2, Mission 1","Null X-1","Sandstorm","Core","10","$600","P_STR07",
		"This barren planet seems to be devoid of any humanoid life, hence the name. Even so, the
		\ndemons have chosen to wage an attack on a recently abandoned core facility which, as it
		\nturns out, may prove useful in future UAC endeavors after all. Restore hope to this
		\nforsaken planet and protect the computer core at all costs!"
	},
	{
		"Tier 2, Mission 2","Gorge","Tropical Paradox","Core","10","$700","P_STR08",
		"What was once an island paradise is now a demon-infested hellhole. This planet was
		\na widely-famed holiday resort for intergalactic tourists, at least before the demons
		\nlanded. Expect heavy resistance to come from all directions towards your stronghold."
	},
	{
		"Tier 2, Mission 3","Herros","Volcanic Installation","Core","3","$800","P_STR09",
		"This storage facility is situated in extremely hostile territory. Swarms of hellspawn
		\nare approaching, and the hazardous lava-filled caverns make for demon breeding
		\ngrounds. Defending this stronghold will be a tricky undertaking, and be prepared
		\nfor the worst, whatever that might be."
	},
	{
		"Tier 2, Mission 4","Cyclone","Skyfire Research","Core","10","$900","P_STR10",
		"This research substation, orbiting the planet Cyclone, is one of many that links
		\nto the main orbital research nexus, also in orbit over the planet. If the demons
		\nsucceed in severing this vital connection, the UAC research network may suffer a
		\ncrippling blow. Be sure to use the station's defensive ion cannon to your advantage."
	},
	{
		"Tier 2, Mission 5","Scorpid","Tunnel","Milestone (Intro)","10","$1000","P_STR11",
		"This stronghold is a truly massive structure, one of the UAC's finest, so it's
		\nexpected that the demons will be attacking it in equally monstrous waves. You
		\nwill have to change your tactics somewhat to ensure the complete security of
		\nthis stronghold. See Lt. Carmack for further briefing."
	},
	{
		"Tier 3, Mission 1","Skorpid","Dangoo Desert","Deadline","10","$1100","P_STR12",
		"A planet as dry and barren as the Sahara, although the demons seem to relish in such
		\nconditions. They are advancing on this tiny stronghold in large numbers, and seek
		\nits immediate destruction. A hazardous task is ahead of you, but you as a marine
		\nare expected to serve the UAC by defending it with your life!"
	},
	{
		"Tier 3, Mission 2","Maelstrom","Inferno","Deadline","10","$1200","P_STR13",
		"Deep within the underground caverns of this fiery asteroid, all hell is quite
		\nliterally breaking loose. This is not so much a stronghold as simply a very large
		\nmining excavation, where we have uncovered the remains of a hellish temple. Quite
		\nobviously, the demon swarms will be flourishing here, so stay totally sharp."
	},
	{
		"Tier 3, Mission 3","Ormantium","Orbit","Deadline","10","$1300","P_STR14",
		"This space station in high orbit over the planet Ormantium is under attack from
		\nheavily-armed demon/cyborg onslaughts. Such invaders require heavy-duty weaponry
		\nto take down, so you'll be provided with plenty of rockets for most of this mission.
		\nYou may, however, also require a certain amount of luck to get through unscathed..."
	},
	{
		"Tier 3, Mission 4","Styx","Armageddon","Core","10","$1400","P_STR15",
		"On this chaotic planet, where fire rains from the constantly stormy sky,
		\ndemons from the foulest of Hell's pits are trying to overrun a vital computer
		\nstation situated on a charred, rocky ridge. The conditions are hostile and the
		\nmonsters are many, but you must still do your utmost to hold them back!"
	},
	{
		"Tier 3, Mission 5","Cerberus","Frozen","Limit (Intro)","7","$1500","P_STR16",
		"This bitterly cold planet houses a vast, powerful UAC stronghold. It could stand
		\na large scale assault from the demonic army of Hell, at least for a while, but
		\nthe massive waves of monsters advancing still pose a threat. This mission will
		\ntest your mettle for crowd control to the limit - literally."
	},
	{
		"Tier 4, Mission 1","Sigma Two","Slaughtered","Core","10","$1600","P_STR17",
		"The dismal planet of Sigma Two is not one of the most preferable locales for a
		\nconsiderably-sized defense stronghold such as this one, but unfortunately the demon
		\nwaves approaching it are sufficient enough in number to level it completely. We
		\ncan't suffer a loss that great, so it's up to you to make this mission a success."
	},
	{
		"Tier 4, Mission 2","Midnat II","Delta Bunker","Limit","10","$1700","P_STR18",
		"An abandoned defense bunker that was utterly stormed during the last demon invasion.
		\nSome of its defensive utilities are still intact, though you won't have many places
		\nto hide, and even fewer chances to hold the advancing waves back. Do all you can under
		\nthe circumstances to stop the hellspawn from destroying it!"
	},
	{
		"Tier 4, Mission 3","Styx","Tarstone Fortress","Limit","10","$1800","P_STR19",
		"This demonic edifice houses a gateway leading directly to our supercluster. Many
		\nbrave soldiers have lost their lives trying to stabilize this sector, but despite
		\ntheir efforts, hordes of demons are still trying to take back the gateway. They will
		\nwreak havoc upon our homeworlds if we lose control of it. It's all up to you."
	},
	{
		"Tier 4, Mission 4","Heloxyd","Snake Corridors","Limit","7","$1900","P_STR20",
		"This dilapidated UAC warehouse was abandoned a while ago when deadly toxins from
		\nthe planet's underground began seeping into it. While the toxins were eventually
		\ncontained, the same can't be said for the hordes of fast, deadly demons that
		\nendanger this stronghold. Defending this base sure won't be a walk in the park."
	},
	{
		"Tier 4, Mission 5","Midnat II","Overmind","Overmind (Intro)","10","$2000","P_STR21",
		"This cold planet, lit only by the spooky aura of its moons, has already been
		\noverrun by the legions of Hell. An enormous, demonic lifeform has been reported
		\ncausing untold chaos on our main control tower stronghold here - so in order to
		\nsurvive, you may have to drastically change your strategies."
	},
	{
		"Tier 5, Mission 1","Rouger","Locus of Pestilence","Deadline","10","$2100","P_STR22",
		"This planet is embraced by an elusive orange fog. A small stronghold has been
		\nconstructed here to allow further study of the various other environmental
		\noddities of this planet. The demons will be arriving to invade every nook and
		\ncranny of this stronghold - so be alert."
	},
	{
		"Tier 5, Mission 2","Chlorine","Bipolar Bunker","Milestone","10","$2200","P_STR23",
		"This is another massive UAC stronghold, constructed within the acidic mines of the
		\nplanet Chlorine. There are many vital control points inside the stronghold itself,
		\nand if the invaders manage to take out all of them, the facility is as good as dead.
		\nBeware though, the monsters are fast and powerful, so use everything at your disposal."
	},
	{
		"Tier 5, Mission 3","Midnat II","Aurora Emitter","Limit","10","$2300","P_STR24",
		"This power facility's energy conductors project beautiful lights into the atmosphere
		\nthat illuminate the surrounding area. Unfortunately the intense lights have attracted
		\nthe attention of the more powerful legions of Hell. Expect heavy resistance from all
		\nsides, and guard the exposed main teleporter at any cost!"
	},
	{
		"Tier 5, Mission 4","Mars","Eye of the Storm","Overmind","10","$2400","P_STR25",
		"The demons are planning an assault on a major Martian defense installation, which
		\nhouses a powerful electromagnetic jammer, designed to prevent demons from storming
		\nthe planet's surface. The Overmind has been reincarnated not far from this stronghold
		\nwith intent to destroy its exterior core network - it must be kept intact!"
	},
	{
		"Tier 5, Mission 5","Deep Space","Deepspace 12","Goals (Intro)","16","$2500","P_STR26",
		"This substantial space station is the hub of the UAC's inter-planetary research network.
		\nIts massive data terminals house crucial information on all of the military branches
		\nand strongholds in this sector. Exabytes of precious data is at stake. Protect every
		\nsingle square inch of this station, or all will be lost."
	},
	{
		"Tier 6, Mission 1","Cyclone","Cyclone","Milestone","7","$2600","P_STR27",
		"The skies of this elusive planet are constantly dancing with the aurora borealis
		\nphenomenon, as it is known on Earth, and luminous crystals dot the landscape.
		\nThis planet is falling rapidly under the demons' influence - and what would
		\notherwise be a visually bountiful planet is turning into a satanic cesspool."
	},
	{
		"Tier 6, Mission 2","Skorpid","Terrorforming","Goals","7","$2700","P_STR28",
		"Our terraforming station on this planet is being surrounded on all sides by demon
		\ninvaders. In the wrong hands, the experimental terraformer device could cause
		\nirreversible damage. You must defend it, AND keep it stable, to prevent the demons
		\nfrom wresting control of the entire planet."
	},
	{
		"Tier 6, Mission 3","Jailba","Emerald Skies","Limit","11","$2800","P_STR29",
		"This stronghold is situated in a floodplain on the planet Jailba. The arrival of the
		\ndemons to this site has caused some massive atmospheric disturbances, so the weather
		\nconditions have harshened dramatically and all personnel have evacuated before the
		\ninevitable flood strikes. The demons will be numerous this time, so gear up well."
	},
	{
		"Tier 6, Mission 4","Deep Space","Convulsion of Nature","Limit","7","$2900","P_STR30",
		"Somehow, on this immense asteroid, the demons have unearthed a dimensional slipgate
		\nthat will allow them to jump lightyears at a time. If they are allowed to rampage all
		\nacross the universe, then humanity will surely be doomed. Be prepared for the worst,
		\nmarine, and block their entrance through the gate through any means necessary!"
	},
	{
		"Tier 6, Mission 5","Null X-1","Shell Shock","Deadline","10","$3000","P_STR31",
		"The demons are attacking one of our main defense installations here on Null X-1. We have
		\nalready lost the station's ion cannon amidst the chaos of their previous attack, and it
		\nis likely they will make use of it during the course of this mission. You must prevent
		\nthe demons from destroying this base and stealing more of its destructive weaponry."
	},
	{
		"Tier 6, Mission 6","Crimson","Dusk","Limit","11","$3100","P_STR32",
		"This planet has been renowned amongst UAC explorers and researchers for having many
		\nparadoxical phenomena. It boasts several somewhat peculiar structures, including this
		\nfloating fortress, which the UAC is beginning to study in greater depth. However,
		\nthe area is already rife with demons, so expect the unexpected."
	},
	{
		"Tier 6, Mission 7","Photon","Antlion Nebula","Milestone","10","$3200","P_STR33",
		"The thick purple fog engulfing the UAC control point in this nebula will only hinder
		\nyou, so we've provided you with a few extra temporary means of defense that may aid you
		\nin holding off the demonic army, while you attempt to navigate the complex structure of
		\nthis stronghold. We wish you luck - this will by no means be an easy task."
	},
	{
		"Tier 6, Mission 8","Rouger","Three Ways to Die","Goals","12","$3300","P_STR34",
		"This planet's thin atmosphere and dangerous proximity to its lethally radioactive
		\nsun make it a hazardous environment. Storms rage violently across its surface,
		\nand a hefty battalion of demons encroaches a series of control towers situated in
		\na particularly hostile area of the planet. Use caution, there's more than one way to die..."
	},
	{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},
	{
		"Secret Mission 1","Earth","Duke it Out","Save the Babes","10","$1500","P_STR50",
		"An alien invasion is taking place on Earth, but not one like any we've seen before.
		\nThe merciless rigelatins have invaded the streets of Los Angeles, destroying
		\nthe city, converting its population into monstrous abominations and abducting
		\nour babes. It's time to nuke those sons-of-bitches hard."
	},
	{},
	{
		"Secret Mission 2","Earth","City of Silence: Apocalypse","Limit","10","$1500","P_STR52",
		"All hell has broken loose. The dead rise, the sky falls, and twisted, satanic
		\nmagicks are abundant. Worse still, nightmarish ghouls rampage through our towns,
		\ntheir demented influence corrupting the very fabric of our world. Doomsday is at
		\nhand, and your speed and wile will be tested to the limit."
	},
	{},
	{
		"Secret Mission 3","Hell","Fortress of Damnation","Goals","10","$1500","P_STR54",
		"While hellspawn rampaged on Earth, the UAC launched their remaining task force against
		\nthe final demon gate in a bid to close it from the other side. One brave marine stood
		\nup, and overthrew the hellish legions single-handedly. In a recreation of this
		\nhistoric battle, your mission is to seal the gate, and secure the control points."
	},
	{},
	{
		"Secret Mission 4","Phobos","Phobos Anomaly","Core","10","$1500","P_STR56",
		"The mining facilities on Phobos revealed this huge, ancient stargate under the moon's
		\nsurface. Just after your arrival, the gate opened and let loose hundreds of demons and
		\nzombies. Your task here is to defend the interior of the mining base from this somewhat
		\nfamiliar onslaught. Will you succeed where your predecessors failed?"
	},
};

// \ce brown <=50Very Low
// \ch blue <=100Low
// \cd green <=300Medium
// \cf gold <=500Medium High
// \ci orange <=1000High
// \cg red >1000Very High
// \ca brick >3000Insane

int MonsterBounty[79][2] =
{
	{1,3},{2,4},{5,8},{3,5},{3,5},
	{4,8},{5,5},{8,8},{3,6},{6,9},
	{5,8},{7,10},{5,5},{8,8},{10,10},
	{5,5},{6,6},{12,12},{8,8},{9,9},
	{10,10},{11,11},{10,10},{64,64},{15,15},
	{8,8},{15,15},{20,20},{12,12},{30,30},
	{15,15},{22,22},{30,30},{40,40},{10,10},
	{16,16},{12,12},{17,17},{12,12},{25,25},
	{20,20},{50,50},{75,75},{50,50},{60,60},
	{240,240},{800,800},{999,999},{9001,9001},{750,750},
	{6,6},{48,48},{10,10},{1,1},{2,2},
	{2,3},{8,8},{6,6},{2,3},{3,3},
	{3,3},{3,3},{3,3},{5,5},{3,3},
	{14,14},{24,24},{16,16},{3,6},{6,6},
	{8,12},{12,12},{12,12},{12,12},{6,10},
	{4,6},{3,6},{2,5},{6,10}
};
str MonsterStats[79][8] =
{
	{
		"StrongholdZombieman","\chSlow","\cuVery Low","Undead","Hitscan","None","S. Priestess",
		"The weakest, and most common enemy. All they have is a pistol, and they're
		\nreally a poor shot. They're only really a threat in large groups, but even
		\nthen they probably cause more collateral damage than they'll do to you. They
		\ndon't put up much of a fight if you shoot them down quickly enough."
	},
	{
		"StrongholdShotgunGuy","\chSlow","\chLow","Undead","Hitscan","None","S. Priestess",
		"A step up from the zombieman; this guy wields a shotgun. He is still not too
		\ntough, but he'll get you good if you let your guard down."
	},
	{
		"StrongholdChaingunGuy","\chSlow","\cdMedium","Undead","Hitscan (Continuous)","None","S. Priestess",
		"Kill from a distance if you can. This guy's weapon will pulverize you in
		\nseconds if you don't have suitable cover. If he's involved in a crossfire, he
		\nwill usually win because his attacks are so painful that they cause other
		\ndemons to slow down."
	},
	{
		"RocketGuy","\chSlow","\cdMedium","Undead","Projectile","None","W. Weasel",
		"These men were once members of our Anti-Tank battalions. They carry the same
		\nkind of rocket launcher as you, and pack a gigantic punch if you're not
		\ncareful. While they go down easy - they're only human, after all - it may be
		\nmore worthwhile to leave them alive for a while to let them accidentally fire
		\ntheir weapons at larger monsters."
	},
	{
		"PlasmaZombie","\chSlow","\cdMedium","Undead","Projectile","None","R. West",
		"Much like the other former humans, these guys will go down easily. Sadly, they
		\ncarry a plasma rifle, and while they don't fire it as fast as you do, it will
		\nstill incinerate you if you aren't careful. It is advised to not let them fire
		\nupon you when you fight them. Worse still, they only drop an energy cell upon
		\ndeath, rather than a plasma rifle."
	},
	{
		"DuneWarrior","\chSlow","\cdMedium","Undead","Projectile and Hitscan","Cloak","J. Paddock",
		"These guys were once some of our most elite stealth units, trained to brave
		\nthe harshest of climates. Their flame bomb launcher and semi-automatic
		\nmachinegun are nothing to get too concerned about, because they also possess a
		\ncloaking device, allowing them to bypass your defense belt virtually unseen
		\nuntil it wears off. Their Achilles' heel is their low health, so if you suspect
		\nthey're around, throw a rocket into an open space and watch any of them nearby
		\ngo flying."
	},
	{
		"SuicideBomber","\cgFast","\cdMedium","Undead","Melee Only","Kamikaze","W. Weasel",
		"A possessed soldier wired up with high explosives. His main goal in life is to
		\nrun towards something destructible and then detonate himself. He's rather hard
		\nto miss; his insane screaming is quite loud and you'll probably hear it from a
		\npretty far distance. Interestingly, though, the souls Hell has chosen to
		\nbecome Kamikazes were evidently those of people who killed themselves
		\nsimilarly in their previous life. I guess if they did one thing well, they
		\ncould always do it again..."
	},
	{
		"ZombieTank","\cgFast","\cdMedium","Undead/Mechanical","Hitscan (Semi-Continuous)","None","J. Paddock",
		"The zombies left with enough brain capacity to retain their driving skills you
		\nwill see swerving around the battlefield in these well-armored UAC vehicles,
		\nfiring the mounted gatling guns in every direction. They can also accelerate to
		\nhigh speeds and as a result capture the objective with relative ease if you
		\ngive them sufficient opportunity. The trick is: don't! Have a suitable weapon
		\non you and make sure to take them out from a distance - destroying them causes
		\nthem to explode in a ball of flame, causing minor damage to everything nearby."
	},
	{
		"StrongholdDoomImp","\chSlow","\chLow","Demon","Projectile and Melee","None","J. Paddock",
		"Forget little dwarf faeries with pick-axes - the real demon is very different.
		\nImps are probably Hell's expendable worker drones, with fire-summoning attacks
		\nthat aren't terribly powerful but threatening all the same, especially when
		\nthey emerge in massive groups, which they often do. Because they're rather
		\nweak, it's easy to take them out with a powerful weapon, so make sure you have
		\none ready in case they choose to bring a few hundred or so of their buddies
		\nalong with them."
	},
	{
		"PhaseImp","\ca???","\cfMedium High","Mutant","Tracer and Melee","Phase","J. Paddock",
		"Among the adjectives used to describe the phase imp are: fast, durable,
		\ndeadly, and annoying. Phase imps appear to be a sort of mutated form of the
		\nregular imp, and unfortunately more than twice as threatening as their lesser
		\ncounterparts. Once you hear that bone-chilling war cry, be sure to terminate
		\nthem quickly, if you can; they can take a heavy amount of shots before biting
		\nthe dirt. If you don't, they will disappear in front of you, before
		\nteleporting beyond the objective and possibly ending your mission in failure.
		\nMake sure you have cover from their homing attacks, as well."
	},
	{
		"Shadow","\cgFast","\cdMedium","Demon","Projectile (Continuous)","None","B. V. Ostmann",
		"This sneaky little stalker may appear weak at first, and its relatively low
		\nhealth seems to back this up. However, its high speed and its semi-transparent
		\nflesh makes this foe a much more serious threat, so stay on the lookout for
		\nthem as they can pass a defense line with ease. Facing a single shadow is
		\na very rare occurence, as they ALWAYS appear in swarms of varying sizes."
	},
	{
		"Catharsi","\chSlow","\cdMedium","Alien","Projectile","Bomb","W. Weasel",
		"Even extraterrestrial life believes in Hell, or at least a variant of it. The
		\nCatharsi don't appear to be demons themselves, but are certainly operating
		\nunder Hell's influence. Their dedication is such that, even when near death,
		\ntheir only goal is the destruction of those who oppose them - watch out for
		\nthe floating detonators that they drop when they die. Skilled marines can use
		\nthese to their advantage, though, by killing one Catharsi in a group of other
		\nmonsters to soften up the rest of them a bit."
	},
	{
		"StrongholdDemon","\cfQuick","\cdMedium","Demon","Melee Only","None","W. Weasel",
		"The first relatively serious threat to new marines, the Demon is fast and
		\npowerful, and takes a beating. Presumably the Demon's origins come from the
		\ndeparted souls of athletes who abused steroids, or perhaps they're the
		\ndeformed offspring of Hell's various nobles. Beware their speed; even if they
		\naren't coming for you, they will almost always be the ones to seize the gates.
		\nCertain variants of these demons appear blurred to human eyes and are hard to
		\nsee effectively."
	},
	{
		"BloodDemon","\cgFast","\cdMedium","Demon/Cyborg","Melee Only","None","W. Weasel",
		"Also nicknamed the \"Steam Demon\", the Blood Demon's craving for speed has
		\nturned it towards cybernetics. Blood Demons are unique for their bionic legs,
		\nwhich they use to run very, very quickly. The downside to that is that they
		\nmake quite a racket when moving around, so if you happen to lose one, listen
		\nfor that signature clanking noise."
	},
	{
		"NightmareDemon","\cgFast","\cfMedium High","Demon","Projectile and Melee","Stealth","J. Paddock",
		"By the time you've noticed a swarm of Nightmare Demons approaching your
		\nobjective, it's usually too late to stop 'em in time. These guys are insanely
		\nfast, and regurgiate plasma balls similar to those hurled by the hell nobles.
		\nNot only that, but they turn semi-invisible when roaming, meaning you'll have
		\nto despatch their numbers within seconds of spotting them. Because they
		\ntypically ambush strongholds in swarms, you'll have to have a weapon with a
		\nhigh destructive capacity to make sure they're taken out with all speed."
	},
	{
		"StrongholdLostSoul","\cgFast","\cdMedium","Demon","Charge","Flight","W. Weasel & S. Priestess",
		"Hell's version of that hyper little puppy that never left you alone. When he
		\ncharges, he's going to be moving fast, so be ready with that itchy trigger
		\nfinger of yours or you're going to have a hell of a time keeping this guy away
		\nfrom the deadline! However, he's easy to dodge, and only poses a threat in
		\ngreat numbers. A good tactic is to try to line them up so that when they
		\nattack you, they bump into each other, or a nearby demon."
	},
	{
		"Guardian","\cfQuick","\cdMedium","Unknown","Projectile","Flight","J. Paddock",
		"The Guardian Cube is like a weak lost soul, but still annoying as hell. They
		\nfly straight to their objective, being sure to brush away anything that they
		\nsee obscuring their goal. They have ranged attacks, too, which they will
		\nlaunch constantly if their target is visible. Target immediately, and take
		\nthem down fast."
	},
	{
		"HS","\cfQuick","\cfMedium High","Unknown","Melee Only","Flight, Phase, Kamikaze","J. Paddock",
		"The hades sphere is not really a demon, more like a ball of sentient bloodlust
		\nthat phases in and out of existence to fool its opposition, before appearing
		\nin front of them again and self-destructing with extreme force. You won't
		\nusually see these guys on your missions, so thank Heaven for that, but the
		\nHades Elemental will vomit these guys out in twos, so if you can get a bead on
		\nthem, make it count, before the battlefield is swarmed by the bastards."
	},
	{
		"Wicked","\chSlow","\cdMedium","Demon","Projectile","Flight","J. Paddock",
		"This peculiar snake-like apparition is like an especially annoying version of
		\nthe cacodemon. He will charge, using his whip-like tail to accelerate towards
		\nhis foe, and when within range, launch a homing fireball which will sooner
		\nor later catch up with them. They are tougher than they appear, so be ready to
		\nclash heads with them for lengthy periods if you don't have a suitable weapon."
	},
	{
		"StrongholdCacodemon","\chSlow","\cdMedium","Demon","Projectile and Melee","Flight","B. V. Ostmann",
		"One of the more common enemies you will face while holding back the demonic
		\nforces. The cacodemon contains a mixture of various noxious gases within its
		\nbody, which not only enables it to hover through the air, but also lets it
		\nproject ignited balls of gas at its prey. The lack of extremities does not
		\nmean that it is incapable of defending itself in close combat; the razor-sharp
		\nteeth and muscular jaws can and will cut through you in an instant."
	},
	{
		"EnhancedCaco","\chSlow","\cdMedium","Mutant","Projectile and Melee","Flight","W. Weasel",
		"So far as we can tell, these guys are pretty much the same as the Cacodemons
		\nyou're used to seeing - helium-filled, projectile-spewing tomatoes. Except
		\nthese guys can shoot even more fireballs at once. The good part? They're no
		\nharder to actually put down than your garden-variety Cacodemon. Just, uh,
		\nremember to stay out of their way."
	},
	{
		"NightmareCaco","\cfQuick","\cfMedium High","Demon/Nightmare","Projectile and Melee","Flight","R. West",
		"These spectral monstrosities make the nightmare demon look nice. Moving faster
		\nthan the ordinary cacodemon, these blue and partially invisible nightmares will
		\nshoot blue fireballs which travel twice as fast as the normal cacodemon fireballs.
		\nIn addition to that, they shoot them out much faster than an ordinary cacodemon.
		\nAdding to THAT is the fact that they are almost twice as tough as the cacodemon."
	},
	{
		"StrongholdPainElemental","\chSlow","\cfMedium High","Demon","Spawn","Flight, Death Spawn","W. Weasel",
		"The Pain Elemental combines the two most irritating things in the world:
		\nmissiles, and Lost Souls. This floating head - which bears an odd resemblance
		\nto those other floaty monsters - launches Lost Souls at high speeds. Guard the
		\nbase entrance carefully when these are around, because if they manage to shoot
		\na Lost Soul past your defenses, you're pretty much screwed. Oh, and be careful
		\nwhere you kill them, too, because they leave behind even more Lost Souls when
		\nthey explode."
	},
	{
		"Helemental","\chSlow","\cdVery High","Demon","\cgOH SHIT","Flight, Phase","J. Paddock",
		"You may well have just met your maker. The Hades Elemental is one of the most
		\npowerful monsters you will encounter, with a deadly arsenal consisting of
		\nlightning attacks, regurgitating Hades Spheres, teleportation, and a mouth so
		\nvast it will swallow anything that happens near it. It takes quite a beating
		\nbefore exploding in a shower of flaming debris (at which point it will spawn
		\neven more Hades Spheres), so you are urged to ensure that you have an extremely
		\npowerful firearm in your possession before confronting this behemoth."
	},
	{
		"StrongholdRevenant","\cfQuick","\cfMedium High","Undead","Projectile, Tracer and Melee","None","S. Priestess",
		"Hell doesn't make waste. Take a dead demon, and strap on some armor and homing
		\nrocket launchers, and you've got this fellow. He also likes to get up close
		\nand personal, so watch out! He's moderately tough to kill."
	},
	{
		"Satyr","\chSlow","\cdMedium","Demon","Melee","None","R. West",
		"These minor nobles are just that - minor. They only have a melee attack, but
		\nthey attack faster than most demons, and do a lot of damage. They do have some
		\nlevel of inherent toughness - but as long as you stay out of their range, they
		\nshouldn't be a problem. Think of them like slower, but tougher blood demons."
	},
	{
		"StrongholdHellKnight","\chSlow","\cdMedium","Demon","Projectile and Melee","None","S. Priestess",
		"A lesser version of the Baron of Hell, this creature's skin is not quite as
		\nflushed, and can only take half the amount of damage as their stronger cousins
		\nbefore dying. They do, however, attack with the same type of plasma, so
		\ncaution is still highly advised against them."
	},
	{
		"StrongholdBaronOfHell","\chSlow","\cfMedium High","Demon","Projectile and Melee","None","S. Priestess",
		"This creature has red flushed skin over the top half of his body, and goat
		\nlegs on the bottom. The Baron of Hell is not as common as some of the other
		\nenemies, but that makes it no less of a threat. He hurls green plasma balls at
		\nhis target which can do moderate to severe damage. He's also pretty tough,
		\ntoo, and it's going to take more than what it usually takes for other enemies
		\nto put him down."
	},
	{
		"HellWarrior","\chSlow","\cfMedium High","Demon","Projectile and Melee","Shield","J. Paddock",
		"The Hell Warrior's monstrous visage is the first thing you'll notice. Then
		\nyou'll notice the huge metal shield he carries. And if you're not careful you
		\nwon't be noticing much more after that. Despite only have 400 hit points
		\n(that's less than a Hell Knight), he's still a formidable adversary. His
		\nshield blasts out flesh-rending energy projectiles, and he can absorb all
		\ndamage while the shield is raised in front of him. He has the standard noble
		\nplasma attack, too."
	},
	{
		"BruiserDemon","\chSlow","\cgVery High","Demon","Projectile, Floor Hugger","None","W. Weasel",
		"Ordinarily we would advise you to run the hell away from these things, but
		\nconsidering you're supposed to be defending outposts and not saving your own
		\nskin, that is unfortunately not an option. So our best advice to you is: take
		\ncover! Our science team is busy analyzing the Bruiser's genetic code, so maybe
		\n- just MAYBE - we might have a way for you to fight back against these things!
		\nUntil then...well, you're on your own."
	},
	{
		"Cybruiser","\chSlow","\cgVery High","Demon","Projectile and Melee","None","W. Weasel",
		"You probably remember the Amish: those Christian folks from Earth that ignored
		\ntechnology in favor of simple lives and hard work. Well, after seeing
		\nmechanical monstrosities like this, don't you wish Hell took a few pages from
		\ntheir book? The Cybruiser basically comes from the same mold as Hell's nobles,
		\nbut is enhanced with the latest advances (i.e. whatever they stole from the
		\nlast base we lost) in targeting systems and anti-vehicle weaponry. This guy
		\nexemplifies why it's so important to guard the outposts in the first place -
		\nto stop stuff like THIS from happening!"
	},
	{
		"ArchonOfHell","\chSlow","\cgVery High","Demon/Cyborg","Projectile and Melee","None","W. Weasel",
		"This guy truly stands out from the rest of the Hell nobles - in more ways than
		\none. First off, he has an unmistakeable black and red hide and boasts huge
		\nspikes all down his upper body. Secondly, he is able to fire volleys of
		\ndevastating green comets that tear through armor and flesh alike. And to top
		\nit all off, he vaporizes in a viscous green cloud upon death. Underneath all
		\nthat, though, he'll go down much like the rest of his brethren. Unfortunately
		\nthe Archon does take a few more hits to beat, and it's much harder to dodge his
		\nattacks, so you still better have your wits about you when you confront him."
	},
	{
		"Azazel","\chSlow","\caInsane!","Demon","\cgEverything!","None","J. Paddock",
		"Not much is known about the Azazel, mainly due to our unfortunate observers
		\ngetting fried every time they try to gather more tactical information on it.
		\nYour best bet when you see it rear its ugly head is to run like hell in the
		\nother direction. If you're standing too close you'll get caught in the range
		\nof its powerful energy discharge attack and get char-grilled. Unload as much
		\nammo as possible on it as you run, 'cause it'll be throwing a plethora of
		\nprojectiles your way, some of which are nigh-impossible to dodge. Easily one
		\nof the most frustrating demons you'll deal with."
	},
	{
		"PyroDemon","\chSlow","\caInsane!","Demon","\cgEverything!","Teleportation","S. Scream",
		"These burning beasts' lust for fire has driven them to utter insanity. They
		\nlove to kill their victims in the most pyromanic ways, even by exploding into
		\na ball of fire and reappearing immediately in front of their target. They pay
		\nno mind to any of their nearby brethren, and fire explosive fireballs in every
		\ndirection they possibly can, just to get a chance to see you burn. Never get
		\ntoo close!"
	},
	{
		"StrongholdFatso","\chSlow","\cfMedium High","Demon/Cyborg","Projectile","None","W. Weasel",
		"The embodiment of gluttony, one of the seven deadly sins. Basically, the
		\nMancubus is the hellish reincarnation of that fat kid from school that gorged
		\nhimself on Twinkies. And now they've given him a pair of high-powered cannons
		\nto compensate for the fact that he can barely move. All that fat will absorb
		\nmost of the damage you do to it, but luckily, he can't really aim very well."
	},
	{
		"Hectebus","\chSlow","\ciHigh","Demon/Cyborg","Projectile","None","J. Paddock",
		"The Hectebus can probably best be described as his lower cousin tanked-up on a
		\nsubstantial amount of illegal substances. A considerable proportion larger
		\nthan the Mancubus, this colossus has been known to reduce stronghold defenders
		\nto primordial slime in an eyeblink with his extremely powerful twin cannons.
		\nHis horribly bulky structure makes him a formidably difficult foe to overcome,
		\nso make sure you have a powerful weapon on you before confronting him."
	},
	{
		"StrongholdArachnotron","\chSlow","\cfMedium High","Demon/Cyborg","Projectile (Continuous)","None","S. Priestess",
		"Every Arachnotron wants to be a Spider Mastermind someday. For now, they have
		\na plasma gun that really hurts if you stay still for too long. If you want to
		\nkill these effectively, use hard heavy shots, and stay out of the plasma
		\nstream. A few rockets will do the trick."
	},
	{
		"FusionSpider","\chSlow","\ciHigh","Demon/Cyborg","Projectile (Continuous)","None","J. Paddock",
		"The arachnotron got a weapon upgrade. Instead of a slow-fire plasma cannon,
		\nthey now have a fusion energy launcher, which releases a field of slow-moving,
		\nhigh-damage energy projectiles in an outward spread pattern. These walls of
		\ndeath crawl forward at an inexorable rate, and are extremely hard to avoid
		\nunless you have some damn good cover. Be sure to note also that the fusion
		\nspider is now slightly harder to kill than its less dangerous, but equally
		\nannoying, counterpart."
	},
	{
		"Hellion","\cfQuick","\cdMedium","Demon","Projectile","None","M. Orpheus",
		"These nasty imp/archvile-like demons come from the deepest caverns of hell.
		\nThey have no hesitation in attacking you with deadly flame bursts. They
		\nusually come in large hordes, much like Shadows, and are just as fast. So our
		\nadvice is to use an effective, rapid-fire weapon in order to take them down as
		\nfast as possible."
	},
	{
		"StrongholdArchVile","\cgFast","\cgVery High","Demon","Distance","Resurrection","S. Priestess",
		"If you thought battling demons ONCE was bad, then this guy will try to make
		\nsure you face them again! And to make things worse, he's got an explosive fire
		\nattack that will hurl you into the air, doing heavy damage. Quick termination
		\nwith extreme prejudice is advised."
	},
	{
		"Diabloist","\cgFast","\cgVery High","Demon","Projectile, Tracer, Distance","None","J. Paddock",
		"Some suspect the Diabloist is a lesser incarnation of Satan himself. Anything
		\nwithin this bastard's attack range (that is, anything within his line of
		\nsight) soon turns to ash. He has several devastating attacks, all of which
		\ninvolve burning, heat, flames, fire... you get the idea. When you see him, run
		\nfor cover. You've got nought else to do if you don't have a weapon equally
		\ngood at clearing a room as he is."
	},
	{
		"StrongholdSpiderMastermind","\chSlow","\cfMedium High","Demon/Cyborg","Hitscan (Continuous)","None","W. Weasel",
		"Mechanical spider, except with half the number of legs, but still deadly. The
		\nbest way to kill her is to attack from far away, and with a BFG. She does not
		\nsuffer explosions like other monsters do. Rumor has it that these brainpans-
		\non-legs used to take more of a beating than they do these days, but let's just
		\nassume that we've gotten better at it. It's better for morale."
	},
	{
		"Demolisher","\chSlow","\cgVery High","Demon/Cyborg","Projectile and Hitscan (Continuous)","None","W. Weasel",
		"Dear God, save us all. The demons got a hold of our BFG technology, and this
		\nis the result. One of the most powerful demons we've seen in a long while,
		\nonly made far worse by double the usual firepower - and that doesn't even
		\ncount the destructive capabilities of the BFG they mounted on the damn thing!
		\nRest assured, Marine, we'll make damned sure you get enough firepower to take
		\nthis thing on, or else you're not going to be the only thing we lose!"
	},
	{
		"StrongholdCyberDemon","\chSlow","\ciHigh","Demon/Cyborg","Projectile","None","S. Priestess",
		"Take a regular demon, supersize him, give him a rocket launcher and other
		\ncybernetic attachments, and this guy is the result. The only way to fight this
		\nguy is with good reflexes and a super fast gun. His rockets are hard to dodge,
		\nand he doesn't feel much pain. He's also immune to explosions, except when he
		\nsuffers a direct impact so rockets and pyro cannons do far less damage to him
		\nthan they do to other creatures. Plasma rifles most effective."
	},
	{
		"Terminator","\chSlow","\caInsane!","Cyborg","Projectile and Hitscan","None","B. V. Ostmann",
		"Hard to differentiate between demon and machine, the terminator is probably
		\nthe toughest enemy you will ever face during your missions. Its vital systems
		\nare not only protected by heavy armor, but also by powerful invisible energy
		\nfields, which allow it to absorb huge amounts of physical damage. In addition,
		\nit seems to have a nigh-infinite arsenal of destructive weaponry. With arm
		\ncannons that launch fast, explosive energy projectiles, missiles that home in
		\non their targets, a machinegun AND a grenade launcher, you must approach this
		\ngoliath with extreme caution, and perhaps a very big gun."
	},
	{
		"Moloch","","","","","","",
	},
	{
		"Overmind","","","","","","",
	},
	{
		"STBoss","","","","","","",
	},
	{
		"SpiritBoss","","","","","","",
	},
	{
		"CyberdemonMk2","","","","","","",
	},
	{
		"MiniCyber","","","","","","",
	},
	{
		"ChaosCyber","","","","","","",
	},
	{
		"Apprentice","","","","","","",
	},
	{
		"MiniSpider","","","","","","",
	},
	{
		"LargeSpider","","","","","","",
	},
	{
		"Thrall","","","","","","",
	},
	{
		"Incarnate","","","","","","",
	},
	{
		"HotDog","","","","","","",
	},
	{
		"Vulgar","","","","","","",
	},
	{
		"ESoul","","","","","","",
	},
	{
		"WraithX","","","","","","",
	},
	{
		"ChaingunCultist","","","","","","",
	},
	{
		"ShotgunCultist","","","","","","",
	},
	{
		"FattyX","","","","","","",
	},
	{
		"ZombieX","","","","","","",
	},
	{
		"Queen","","","","","","",
	},
	{
		"Cycloid","","","","","","",
	},
	{
		"Overlord","","","","","","",
	},
	{
		"AlienDrone","","","","","","",
	},
	{
		"KamikazeSentry","","","","","","",
	},
	{
		"Commander","","","","","","",
	},
	{
		"BattleLord","","","","","","",
	},
	{
		"BattleLordPal","","","","","","",
	},
	{
		"SuperBattleLord","","","","","","",
	},
	{
		"OctaBrain","","","","","","",
	},
	{
		"LizardCommando","","","","","","",
	},
	{
		"PigCop","","","","","","",
	},
	{
		"DukeFodder","","","","","","",
	},
	{
		"TeleFodder","","","","","","",
	}
};

script "AwardPoints"(int mode)
{
	int monster;
	for(int i=0;i<=45&&!monster;i++)
		if(CheckActorClass(0,MonsterStats[i][0]))
			monster=i;
	SetActivator(0,AAPTR_TARGET);
		GiveInventory("CoinItem",MonsterBounty[monster][mode]);
}

Script "FastMonsters"(void)
{
	if(GetCVar("sv_fastmonsters")||GameSkill()>=4)
		SetResultValue(1);
	else
		SetResultValue(0);
}

/* ******************************* **
** Public defines, for maps to use **
** ******************************* */

// Player 1 tid is PLAYER_TID_START, Player 2 tid is PLAYER_TID_START+1, etc.
#libdefine	PLAYER_TID_START	5000

// Radio stuff
#libdefine	RADIO_RANDOM	0
#libdefine	RADIO_PETERSEN	1
#libdefine	RADIO_PRINCE	2
#libdefine	RADIO_WILBUR	3
#libdefine	RADIO_CLOUD		4
#libdefine	RADIO_TAYLOR	5
#libdefine	RADIO_POTHEM	6
#libdefine	RADIO_CRESSWELL	7
#libdefine	RADIO_HARRELL	8
#libdefine	RADIO_GIMMER	9
#libdefine	RADIO_OSTMANN	10
#libdefine	RADIO_DRAGON	11
#libdefine	RADIO_CARNEY	12
#libdefine	RADIO_CLAUSSEN	13
#libdefine	RADIO_EMMIRATH	14
#libdefine	RADIO_KILLSAW	15
#libdefine	RADIO_METER		16

// Script numbers
#libdefine	S_BF_THRUST	254
#libdefine	S_G_THRUST	253

// Game modes
#libdefine	S_DEADLINE	901
#libdefine	S_CORE_GAME	902
#libdefine	S_MILESTONE	903
#libdefine	S_LIMIT_GAME	904
#libdefine	S_OVERMIND	905
#libdefine	S_GOAL_GAME	906

#libdefine	S_GETBONUS	980
#libdefine	S_MINUTECHECKS	981
#libdefine	S_DAMAGECHECKS	982
#libdefine 	S_DETECTENDOFLVL 983

#libdefine	S_MILE_MARKER	250
#libdefine	S_LIMIT_MARKER	249

#libdefine	S_MISSION_COMPLETE	910
#libdefine	S_M_ACTIVATE_FAIL	255
#libdefine	S_MISSION_FAIL	912
#libdefine	S_JAIL_GIVEUP	252
#libdefine	S_JAIL_LEAVE	898
#libdefine	S_JAIL_OPEN	897
#libdefine	S_BRIEF_END	251
#libdefine	S_BRIEF_MAIN	925

#libdefine	S_STR52CODEGET	927

#libdefine	S_GOAL_DESTROYED	926
#libdefine  S_CORE_WARNINGS     929

#libdefine	S_HARD_MODE_CHECK	935
#libdefine	S_I_WIN_BUTTON	936

#libdefine	GOAL_RED	1
#libdefine	GOAL_ORANGE	2
#libdefine	GOAL_BLUE	3
#libdefine	GOAL_GREEN	4
#libdefine	GOAL_WHITE	5

#libdefine	WATCH_UNKN	0
#libdefine	WATCH_CORE	1
#libdefine	WATCH_BOSS	2
#libdefine	WATCH_BOSSTARGET	3
#libdefine	WATCH_LIMIT	4
#libdefine	WATCH_GOALS	5

// Many of these are not used.
#libdefine B_TIMEHALF 0
#libdefine B_TIMETHIRD 1
#libdefine B_TIMEQUARTER 2
#libdefine B_KILLS100 3
#libdefine B_KILLS200 4
#libdefine B_KILLS300 5
#libdefine B_NOMILESTONES 6
#libdefine B_NOGOALS 7
#libdefine B_CORE90 8
#libdefine B_CORE95 9
#libdefine B_CORE100 10
#libdefine B_LIMITHALF 11
#libdefine B_LIMITQUARTER 12
#libdefine B_LIMITNONE 13
#libdefine B_OVERMINDKILLER 14
#libdefine B_NOCORES 15
#libdefine B_INDIRECTKILLS1 16
#libdefine B_INDIRECTKILLS2 17
#libdefine B_INDIRECTKILLS3 18
#libdefine B_CASH10K 19
#libdefine B_CASH20K 20
#libdefine B_CASH30K 21
#libdefine B_DAMAGE100 22
#libdefine B_DAMAGE50 23
#libdefine B_NODAMAGE 24
#libdefine B_NIGHTMARE 25

#libdefine GAME_DEADLINE 0
#libdefine GAME_CORE 1
#libdefine GAME_MILESTONE 2
#libdefine GAME_LIMIT 3
#libdefine GAME_OVERMIND 4
#libdefine GAME_GOAL 5

// Misc
#libdefine	INT_MAX		0x7FFFFFFF

/* *************************************** **
** Public Variables that can be set by map **
** *************************************** */
int F_CallNextWave; //Cheat variable to force next wave.
int Waves,GameMode=GAME_DEADLINE,HateEpicenter,NumberOfTargets,BossMonster,BossTarget,
BossHealth=25000,EventScript,GoalScript,MileScript,CurrentMile,ExitPos,PrisonSpot,
PrisonExit,PrisonCamStart,PrisonTeleporterLineId,PrisonTeleporterThrustAngle,PrisonExitThrustAngle=-1,
TeleporterOnLight,TeleporterOffLight;
int BreakTime=-1;	// Deadline default is 6*35. Can be overridden by map.
int LimitMax=100;	// Can be overridden by map
int tics_between_monster_spawns=1;	// Can be overridden, but highly not recommended to shorten this either.
bool GameActive=TRUE;	// When this is false, the player can't lose lives
bool GameVictory,TrainingMap,TimeAttackMode;
bool GivePistol=TRUE;	// Set to false for Intermap
bool BriefSkippable=TRUE;	// If this is false, "Press <use> to skip" won't be shown
bool BriefTalking;	// When true, talking animation in briefing happens
bool BriefActive;	// Should be TRUE when players should be frozen (PROP_TOTALLY_FROZEN)
bool BriefNoGun;	// The player won't be given a gun on first spawn while this is true
int BriefScript;	// Set to script number of briefing script. See STR01 for example.
int DamageTaken[32];
bool PlayersAreLate;
int LatePlayersDelay=35*60; // Time before late players are put into jail immediately.
str BriefBackground;
int HardScalerPlayerCount = 7; //Used for player scaling

#libdefine RADIONAME_SIZE	16
int RadioName[RADIONAME_SIZE];

int MapCoinReward[57]=
{
	0,
	0,100,200,300,400,500,600,700,800,900,
	1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,
	2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,
	3000,3100,3200,3300,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,1500,
	0,1500,0,1500,0,1500
};
int MapParTime[57]=
{
	0,
	4*60,10*60,20*60,12*60,16*60,20*60,18*60,16*60,12*60,18*60,
	18*60,20*60,16*60,22*60,25*60,45*60,20*60,32*60,30*60,25*60,
	10*60,18*60,35*60,33*60,12*60,48*60,44*60,40*60,38*60,45*60,
	20*60,50*60,36*60,60*60,90*60,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,20*60,
	0,24*60,0,55*60,0,33*60
};

// 0=level not finished
// -1=level finished, but par-time not met
// Positive number=Par time met, equals high score (in tics)
global int 1:MapScores[];
global int 2:str52code[];	// Has 5 entries, one for each digit of the code

global bool 2:str52codeinit;	// Once str52code has been set, this is set to true

global bool 51:STR50Open;
global bool 53:STR52Open;
global bool 55:STR54Open;
global bool 56:STR56Open;

// These next few shouldn't be changed - pretend they're defines :P
// (They're not set as defines so that way maps don't need to recompile if they're changed.)
int BriefX=370.0,BriefY=365.0,BriefHID=1004,BriefExtraHID=1003;

/* **************************************************** **
** Internal defines and variables, not referenceable or **
** should not be referenced from outside this file.     **
** **************************************************** */

#define	TEMP_TID_START	4600
#define	TEMP_TID_END	4999

#define S_LATEPLAYERS 667
#define S_RESPAWN	670
#define S_DISCONNECT	923
#define	S_CALLWAVE	920
#define S_MESSAGE	921
#define S_UPDATE_MONSTER_COUNT	922
#define S_BRIEF_ANIMATE	924
#define	S_HEALTH_WATCH	911
#define	S_COUNT_WATCH	914
#define	S_LIMIT_WATCH	928
#define	S_OVERMIND_COMPLETE	918
#define	S_HUD_COINS	919

#define S_HUD		915
#define	S_TIMER		916
#define	S_SYNC		917
#define	S_VAR_CHECK	970

#define	S_DEBUG		930

// Multiplier function defines
#define M_MEDIC		1
#define M_AMMO		2
#define M_POWERUP	3
#define M_ENEMIES	4
#define M_BOSSHEALTH	5

#define	SYNC_WAVE	1
#define	SYNC_HITIME	2
#define	SYNC_LOTIME	3
#define	SYNC_PARTIME	4

#define	BriefTalkBoxX	290.0
#define	BriefTalkBoxY	360.0

#define	RadioMugHID	4
#define	RadioNameHID	5
#define	RadioTextHID	6
#define	RadioBoxHID	7

#define	BriefNameHID	1005
#define	BriefTalkBoxHID	1008
#define	BriefBGHID	1010
#define	BriefSkipHID	1002

#define	EndMessageHID	1015
#define FadeOutHID	1016

#define	CoreGraphicHID	1020
#define	CorePercentHID	1021
#define	CoreLabelHID	1022

#define	CoreHIDOffset	3
// HIDs 1023-1029 reserved

#define	HUDLevelHID	1030
#define	HUDMonstersHID	1031
#define	HUDWaveHID	1032
#define	HUDTimeHID	1033
#define	HUDParTimeHID	1034
#define	HUDParTimeLabelHID	1035
#define	HUDBodyCountHID	1036

#define	HUDRightHID	1050
#define	HUDLeftHID	1051

#define	MoneyCountHID	1100
#define	MoneyBarHID	1101

#define	CoreGraphicX	50.2
#define	CoreGraphicY	390.0
#define	CoreLabelX	50.1
#define	CoreLabelY	380.0
#define	CorePercentX	88.2
#define	CorePercentY	395.0

#define	CoreYOffset	(-30.0)

#define	WatchHudSizeX	640
#define	WatchHudSizeY	430

int lastWeaponTid,MonstersTid,highestPlayerNumber,randomRadioFace,msgEndOfLine,msgCurTurn,TimerIsLive;
bool isSetup;
int AllVarsLocal;	// If this is false, then we're a client in a Skulltag client/server setup

int levelRunningTime,levelMinutes,levelSeconds;
str levelSecondsSpace="0";

// Value, Meaning
// 0	No par time shown
// 1	"Par Time" shown
// 2	"Best Time" shown
int parTimeMode,parTime,parTimeMinutes,parTimeSeconds;
str parTimeSecondsSpace="0";

bool jailTeleporter;
int LimitCounter;	// Number of monsters that have crossed the limit
int curWave;	// Only to be used for display purposes
bool DisableAnnounceWaveDone;	// When TRUE, finishing a wave isn't announced. Used for Overmind mode.
bool GameFinishing;	// When set to true, causes all currently running waves to shut down

#define	LEN_RADIO	16
str RadioData[LEN_RADIO][2]=
{
	{"Cpl. S. Petersen","DIALOG1"},
	{"Sgt. R. Prince","DIALOG2"},
	{"Lt. J. Wilbur",""},
	{"Col. K. Cloud",""},
	{"Pvt. D. Taylor",""},
	{"Sgt. A. Pothem",""},
	{"Cpl. J. Cresswell",""},
	{"Col. B. Harrell",""},
	{"Lt. D. Gimmer",""},
	{"Col. B. Ostmann",""},
	{"Pvt. G. Dragon",""},
	{"Sgt. B. Carney",""},
	{"Cpl. R. Claussen",""},
	{"Lt. R. Emmirath",""},
	{"Col. S. Killsaw",""},
	{"Pvt. G. Meter",""}
};

str WaveNumber[21][2]=
{
	{"Final","T_WAVFNL"},
	{"First","T_WAVNR1"},{"Second","T_WAVNR2"},{"Third","T_WAVNR3"},{"Fourth","T_WAVNR4"},{"Fifth","T_WAVNR5"},
	{"Sixth","T_WAVNR6"},{"Seventh","T_WAVNR7"},{"Eighth","T_WAVNR8"},{"Ninth","T_WAVNR9"},{"Tenth","T_WAVN10"},
	{"Eleventh","T_WAVN11"},{"Twelfth","T_WAVN12"},{"Thirteenth","T_WAVN13"},{"Fourteenth","T_WAVN14"},{"Fifteenth","T_WAVN15"},
	{"Sixteenth","T_WAVN16"},{"Seventeenth","T_WAVN17"},{"Eighteenth","T_WAVN18"},{"Nineteenth","T_WAVN19"},{"Twentieth",""},
};

#define	MILE_ANNOUNCE_SOUNDS_LEN	4
str MileAnnounceSounds[MILE_ANNOUNCE_SOUNDS_LEN]=
{
	"",
	"T_MLSTN1","T_MLSTN2","T_MLSTN3"
};

#define MAXBONUSES 26
int BonusArray[MAXBONUSES][3] = {
// Icon     Name                        Description                                                Award
//-------------------------------------------------------------------------------------------------------
// Time bonuses.
{"B_TIME1", "\ceTIMESTEALER",			"Completed the mission in half the par time.",             },//500},
{"B_TIME2", "\ceTIMESPLITTER",			"Completed the mission in a third of the par time.",       },//1000},
{"B_TIME3", "\ceTIMESLICER",			"Completed the mission in a quarter of the par time.",     },//1500},
// Killing bonuses.
{"B_KILL1", "\cgCARNAGE",				"Killed 100 monsters in 1 minute.",                        },//250},
{"B_KILL2", "\cgCRUSADER",				"Killed 200 monsters in 1 minute.",                        },//500},
{"B_KILL3", "\cgCATACLYSM",				"Killed 300 monsters in 1 minute.",                        },//750},
// Defense bonuses.
{"B_MILE",  "\chMILESTONE DEFENDER",	"Didn't let the demons cross one milestone.",              },//2000},
{"B_GOAL",  "\chGOAL DEFENDER",			"Didn't let the demons destroy one goal.",                 },//1000},
// Core bonuses.
{"B_CORE1", "\cdCORE PROTECTOR",		"Completed the mission with the core at 80%-89%.",         },//200},
{"B_CORE2", "\cdCORE PRESERVER",		"Completed the mission with the core at 90%-99%.",         },//600},
{"B_CORE3", "\cdCORE PERFECTOR",		"Completed the mission with the core at 100%!",            },//1000},
// Limit bonuses.
{"B_LIMIT1","\cfLIMIT PROTECTOR",		"Monster limit did not exceed half.",                      },//500},
{"B_LIMIT2","\cfLIMIT PRESERVER",		"Monster limit did not exceed one quarter.",               },//750},
{"B_LIMIT3","\cfLIMIT PERFECTOR",		"Didn't let a single demon pass the deadline!",            },//1000},
// Overmind bonuses.
{"B_OVER1", "\caOVERKILL",				"Killed the overmind without killing any other monsters.", },//1000},
{"B_OVER2", "\caOVERRIDE",				"Didn't let the Overmind destroy one core.",               },//3000},
// Indirect kill bonuses.
{"B_INDK1", "\ciMODERATOR",				"Killed 100 monsters indirectly.",                         },//200},
{"B_INDK2", "\ciMANIPULATOR",			"Killed 200 monsters indirectly.",                         },//600},
{"B_INDK3", "\ciMASTERMIND",			"Killed 300 monsters indirectly.",                         },//1000},
// Cash bonuses.
{"B_CASH1", "\cqMONEY MERCHANT",		"Accumulated more than $10000 Credits.",                   },//500},
{"B_CASH2", "\cqMONEY MAGNET",			"Accumulated more than $20000 Credits.",                   },//1000},
{"B_CASH2", "\cqMONEY MASTER",			"Accumulated more than $30000 Credits.",                   },//1500},
// Damage bonuses.
{"B_DAMG1", "\ctUNSTOPPABLE",			"Took less than 100 damage overall.",                      },//1000},
{"B_DAMG2", "\csINHUMAN",				"Took less than 50 damage overall.",                       },//2500},
{"B_DAMG3", "\cnGODLIKE",				"Took no damage overall.",                                 },//5000},
{"B_NIGHTM","\cbDOMINATOR",				"Played on Nightmare mode.",                               },//2000},
};

int BonusAwards[MAXBONUSES] =
{500,1000,1500,250,500,750,2000,1000,200,600,1000,500,750,1000,1000,3000,200,600,1000,500,1000,1500,1000,2500,5000,2000};

// Spots arrays
#define MAX_WEAPON_SPOTS	32
int WeaponSpots[MAX_WEAPON_SPOTS];
int WeaponSpotsUsed;

#define MAX_MEDIC_SPOTS		32
int MedicSpots[MAX_MEDIC_SPOTS];
int MedicSpotsUsed;

#define MAX_AMMO_SPOTS		32
int AmmoSpots[MAX_AMMO_SPOTS];
int AmmoSpotsUsed;

#define MAX_POWERUP_SPOTS	32
int PowerupSpots[MAX_POWERUP_SPOTS];
int PowerupSpotsUsed;

// Object spawn arrays

// EnemyEntries[] format is {int wave,str actor,int number}
#define MAX_ENEMY_ENTRIES	512
int EnemyEntries[MAX_ENEMY_ENTRIES][3];
int EnemyEntriesUsed;

// ZoneData[] format is {int x,int y,int xlength,int yheight,int floor,int goal,int byteangle,int zheight,int lowertid,int highertid}
#define MAX_ZONES	24
#define	ZONEDATA_WIDTH	12
int ZoneData[MAX_ZONES][ZONEDATA_WIDTH];
int ZoneDataUsed;

// WeaponItems[] format is {int wave,str actor}
#define MAX_WEAPON_ITEMS	256
int WeaponItems[MAX_WEAPON_ITEMS][2];
int WeaponItemsUsed;

// MedicItems[] format is {int wave,str actor,int number}
#define MAX_MEDIC_ITEMS		2048
int MedicItems[MAX_MEDIC_ITEMS][3];
int MedicItemsUsed;

#define MAX_POWERUP_ITEMS	1024
int PowerupItems[MAX_POWERUP_ITEMS][3];
int PowerupItemsUsed;

// AmmoEntries[] format is {int wave,int type,int amount}
#define MAX_AMMO_ENTRIES	1024
int AmmoEntries[MAX_AMMO_ENTRIES][3];
int AmmoEntriesUsed;

// AmmoActors[] format is {int type,str actor,int amount}
int AmmoActors[11][2]=
{
	{1,10},{1,50},{2,4},{2,20},{3,1},
	{3,5},{4,20},{4,100},{5,24},{5,96},
	{6,2}
};
int AmmoActorsUsed=11;
int AmmoActorsNames[11]=
{
	"Clip","ClipBox","Shell","ShellBox","RocketAmmo",
	"RocketBox","Cell","CellPack","Gas","Fuel",
	"Mines"
};

// MapRewards[] format is {str actor,int amount}
#define MAX_MAP_REWARDS		32
int MapRewards[MAX_MAP_REWARDS][2];
int MapRewardsUsed;

// RadioMessages[] format is {int wave,int name,str message}
#define MAX_RADIO_MSGS		512
#define RADIO_MSGS_WIDTH	3
int RadioMessages[MAX_RADIO_MSGS][RADIO_MSGS_WIDTH];
int RadioMessagesUsed;

// Temp storage arrays

// WaveFinishCallback[] format is {bool isFinished}
#define MAX_NORMAL_WAVES	40
int WaveFinishCallback[MAX_NORMAL_WAVES];

#define MAX_ENEMIES_PER_WAVE	8192

// EnemySpawnCache[] format is {int loc,str actor}
// ENEMY_SPAWN_CACHE_LEN is the limit of how many concurrent waves can be running at once.
#define ENEMY_SPAWN_CACHE_LEN	8
int EnemySpawnCache[ENEMY_SPAWN_CACHE_LEN][MAX_ENEMIES_PER_WAVE];
int EnemySpawnCacheUsed[ENEMY_SPAWN_CACHE_LEN];
int EnemySpawnCacheLoc;

// ItemFogCache[] format is {int spottid,int time}
#define ITEMFOG_CACHE_LEN	16
int ItemFogCache[ITEMFOG_CACHE_LEN][2];
int ItemFogCacheLoc;

// How many tics ItemFogSpawner() has to wait before being able to do fog again at a specific tid.
// Useful to prevent it being called many times at the same spot at the same time.
#define ITEMFOG_REQUIRED_TIC_DIF	6

/* ********* **
** Functions **
** ********* */

function int abs(int x)
{
	if(x < 0)
		return -x;
	return x;
}

function int min(int a,int b)
{
	if(a < b)
		return a;
	return b;
}

function int max(int a,int b)
{
	if(a > b)
		return a;
	return b;
}

function int fdistancexy(int x1,int y1,int x2,int y2)
{
	int len,ang,x=x1 - x2,y=y1 - y2;
	ang=vectorangle(x,y);
	if(((ang+0.125)%0.5) > 0.25)
		len=fixeddiv(y,sin(ang));
	else
		len=fixeddiv(x,cos(ang));
	return len;
}

// Returns fixed point value
function int floor(int fixedNumber)
{
	return fixedNumber & 0xFFFF0000;
}

// Returns fixed point value
function int fround(int fixedNumber)
{
	return floor(fixedNumber + 0.5);
}

// Function from http://zdoom.org/wiki/Getaspectratio
#define ASPECT_4_3(4.0 / 3)
#define ASPECT_5_4 1.25
#define ASPECT_16_9(16.0 / 9)
#define ASPECT_16_10 1.6

function int getaspectratio(void)
{
	int width=getcvar("vid_defwidth");
	int height=getcvar("vid_defheight");
	int nowidescreen=getcvar("vid_nowidescreen");
	int tft=getcvar("vid_tft");
	int aspect=getcvar("vid_aspect");
	switch(aspect)
	{
		case 1:	return ASPECT_16_9;
		case 2:	return ASPECT_16_10;
		case 3:	return ASPECT_4_3;
		case 4:	return ASPECT_5_4;
	}
	if(nowidescreen)
	{
		if(!tft)
			return ASPECT_4_3;
		if(fixedmul(height<<16,fixeddiv(5.0,4.0))==width<<16)
			return ASPECT_5_4;
		else
			return ASPECT_4_3;
	}
	if(abs((abs(fixedmul(height<<16,fixeddiv(16.0,9.0)))>>16) - width) < 10)
		return ASPECT_16_9;
	if(abs((abs(fixedmul(height<<16,fixeddiv(16.0,10.0)))>>16) - width) < 60)
	{
		if((width==320 && height==200) ||(width==640 && height==400))
			return ASPECT_4_3;
		return ASPECT_16_10;
	}
	if(fixedmul(height<<16,fixeddiv(5.0,4.0))>>16==width && tft)
		return ASPECT_5_4;
	return ASPECT_4_3;
}

// Used to pad times and other fixed width numbers in output
// space(1,3) returns "00", space(12,3) returns "0", space(123,3) returns ""
str zerospaces[8]={"","0","00","000","0000","00000","000000","0000000"};
function str zerospace(int num,int spaces)
{
	int difference=spaces-numLen(num);
	if(difference>0&&difference<=7&&num>=0)
		return zerospaces[difference];
	return "";
}

// Returns number of characters num is
function int numLen(int num)
{
	int i=1;
	while(abs(num)/pow(10,i-1) >=10)
		i++;
	if(num<0) // Count the "-" sign
		i++;
	return i;
}

function int pow(int x,int n)
{
	if(n < 1)
		return 1;
	int y=x;
	while(--n)
		y *=x;
	return y;
}

// Level settings

function void AddWeaponSpot(int tid)
{
	if(WeaponSpotsUsed==MAX_WEAPON_SPOTS)
		PrintBold(s:"Error: WeaponSpots[] limit hit");
	WeaponSpots[WeaponSpotsUsed++]=tid;
}

function void AddMedicSpot(int tid)
{
	if(MedicSpotsUsed==MAX_MEDIC_SPOTS)
		PrintBold(s:"Error: MedicSpots[] limit hit");
	MedicSpots[MedicSpotsUsed++]=tid;
}

function void AddAmmoSpot(int tid)
{
	if(AmmoSpotsUsed==MAX_AMMO_SPOTS)
		PrintBold(s:"Error: AmmoSpots[] limit hit");
	AmmoSpots[AmmoSpotsUsed++]=tid;
}

function void AddPowerupSpot(int tid)
{
	if(PowerupSpotsUsed==MAX_POWERUP_SPOTS)
		PrintBold(s:"Error: PowerupSpots[] limit hit");
	PowerupSpots[PowerupSpotsUsed++]=tid;
}

function void AddZone(int bottomlefttid,int toprighttid,int patrolnode)
{
	AddZoneMile(bottomlefttid,toprighttid,patrolnode,0);
}

function void AddZoneAlt(int bottomlefttid,int toprighttid,int patrol1,int patrol2)
{
	AddZoneBase(bottomlefttid,toprighttid,patrol1,0,patrol2,0,0);
}

function void AddZoneMile(int bottomlefttid,int toprighttid,int patrolnode,int mile)
{
	AddZoneBase(bottomlefttid,toprighttid,patrolnode,mile,0,0,0);
}

function void AddZoneAltMile(int bottomlefttid,int toprighttid,int patrol1,int patrol2,int mile)
{
	AddZoneBase(bottomlefttid,toprighttid,patrol1,mile,patrol2,0,0);
}

function void AddZoneBase(int bottomlefttid,int toprighttid,int patrol1,int mile,int patrol2,int unused1,int unused2)
{
	if(ZoneDataUsed==MAX_ZONES)
		PrintBold(s:"Error: ZoneData[] limit hit");
	// Check if this zone has already been added
	for(int i=0; i<ZoneDataUsed; i++)
	{
		if((ZoneData[i][5]==patrol1) &&
			(ZoneData[i][8]==min(bottomlefttid,toprighttid)) &&
			(ZoneData[i][9]==max(bottomlefttid,toprighttid)) &&
			(ZoneData[i][10]==mile) &&
			(ZoneData[i][11]==patrol2))
			// Zone has already been added, so do nothing.
			return;
	}
	ZoneData[ZoneDataUsed][0]=min(GetActorX(bottomlefttid),GetActorX(toprighttid));
	ZoneData[ZoneDataUsed][1]=min(GetActorY(bottomlefttid),GetActorY(toprighttid));
	ZoneData[ZoneDataUsed][2]=abs(GetActorX(bottomlefttid)-GetActorX(toprighttid));
	ZoneData[ZoneDataUsed][3]=abs(GetActorY(bottomlefttid)-GetActorY(toprighttid));
	ZoneData[ZoneDataUsed][4]=min(GetActorZ(bottomlefttid),GetActorZ(toprighttid));
	ZoneData[ZoneDataUsed][5]=patrol1;
	ZoneData[ZoneDataUsed][6]=GetActorAngle(bottomlefttid) >> 8;
	ZoneData[ZoneDataUsed][7]=abs(GetActorZ(bottomlefttid)-GetActorZ(toprighttid));
//	Store the tids used for the mapspots so that the zone can be referenced by functions
//	such as RemoveZone() by them.
	ZoneData[ZoneDataUsed][8]=min(bottomlefttid,toprighttid);
	ZoneData[ZoneDataUsed][9]=max(bottomlefttid,toprighttid);
	ZoneData[ZoneDataUsed][10]=mile;
	ZoneData[ZoneDataUsed][11]=patrol2;
	ZoneDataUsed++;
}

function bool RemoveWeaponSpot(int tid)
{
	int i,j,foundTids;
	for(i=0; i<WeaponSpotsUsed; i++)
	{
		if(WeaponSpots[i]==tid)
		{
			WeaponSpotsUsed--;
			foundTids++;
			for(j=i; j<WeaponSpotsUsed; j++)
			{
				WeaponSpots[j]=WeaponSpots[j+1];
			}
			i--;
		}
	}
	if(foundTids > 0)
		return true;
	return false;
}

function bool RemoveMedicSpot(int tid)
{
	int i,j,foundTids;
	for(i=0; i<MedicSpotsUsed; i++)
	{
		if(MedicSpots[i]==tid)
		{
			MedicSpotsUsed--;
			foundTids++;
			for(j=i; j<MedicSpotsUsed; j++)
			{
				MedicSpots[j]=MedicSpots[j+1];
			}
			i--;
		}
	}
	if(foundTids > 0)
		return true;
	return false;
}

function bool RemoveAmmoSpot(int tid)
{
	int i,j,foundTids;
	for(i=0; i<AmmoSpotsUsed; i++)
	{
		if(AmmoSpots[i]==tid)
		{
			AmmoSpotsUsed--;
			foundTids++;
			for(j=i; j<AmmoSpotsUsed; j++)
			{
				AmmoSpots[j]=AmmoSpots[j+1];
			}
			i--;
		}
	}
	if(foundTids > 0)
		return true;
	return false;
}

function bool RemovePowerupSpot(int tid)
{
	int i,j,foundTids;
	for(i=0; i<PowerupSpotsUsed; i++)
	{
		if(PowerupSpots[i]==tid)
		{
			PowerupSpotsUsed--;
			foundTids++;
			for(j=i; j<PowerupSpotsUsed; j++)
				PowerupSpots[j]=PowerupSpots[j+1];
			i--;
		}
	}
	if(foundTids > 0)
		return true;
	return false;
}

function void ClearItemSpawnSpots(void)
{
	WeaponSpotsUsed=0;
	MedicSpotsUsed=0;
	AmmoSpotsUsed=0;
	PowerupSpotsUsed=0;
}

function bool RemoveZone(int bottomlefttid,int toprighttid)
{
	int i,j,z,foundTids;
	for(i=0; i<ZoneDataUsed; i++)
	{
		if((ZoneData[i][8]==min(bottomlefttid,toprighttid)) &&
			(ZoneData[i][9]==max(bottomlefttid,toprighttid)))
		{
			ZoneDataUsed--;
			foundTids++;
			for(j=i; j<ZoneDataUsed; j++)
			{
			//	ZoneData[j]=ZoneData[j+1];
				for(z=0; z<ZONEDATA_WIDTH; z++)
					ZoneData[j][z]=ZoneData[j+1][z];
			}
			i--;
		}
	}
	if(foundTids > 0)
		return true;
	return false;
}

function bool ChangeZonePatrol(int bottomlefttid,int toprighttid,int newPatrol)
{
	int changed;
	for(int i=0; i<ZoneDataUsed; i++)
	{
		if((ZoneData[i][8]==min(bottomlefttid,toprighttid)) &&
			(ZoneData[i][9]==max(bottomlefttid,toprighttid)))
		{
			ZoneData[i][5]=newPatrol;
			changed++;
		}
	}
	if(changed > 0)
		return true;
	return false;
}

function void ClearZones(void)
{
	ZoneDataUsed=0;
}

function void ClearSettings(void)
{
	ClearZones();
	ClearItemSpawnSpots();
}

Script S_DETECTENDOFLVL ENTER
{
	while(!GameVictory)
		delay(35);
	if(GetLevelInfo(LEVELINFO_LEVELNUM)!=1)
		GetEndBonuses(1);
}

function void AddMapReward(str actor,int amount)
{
	if(MapRewardsUsed==MAX_MAP_REWARDS)
		PrintBold(s:"Error: MapRewards[] limit hit");
	MapRewards[MapRewardsUsed][0]=actor;
	MapRewards[MapRewardsUsed++][1]=amount;
}

//Added by Jimmy. Tweak if needed.
int bonuses[32];
int BonusQueue[MAXBONUSES];

function void GetBonus(int bonustype)
{
	bonuses[playernumber()]++;
	log(i:bonustype,s:"    ",i:bonuses[playernumber()]);
	BonusQueue[bonuses[playernumber()]]=bonustype;
	LocalAmbientSound("Cash",128);
}

script S_GETBONUS(int bonustype)
{
	SetHudSize(800,600,1);
	SetFont("BigFont");
	str bigmessage="";
	if(bonuses[playernumber()])
		bigmessage="Extra Bonuses Awarded!";
	HudMessage(s:bigmessage; HUDMSG_FADEOUT|HUDMSG_LOG,200,CR_WHITE,400.4,392.2,4.0+bonuses[playernumber()],1.0);
	SetFont("ConFont");
	for(int i=1; i<=bonuses[playernumber()]; i++)
	{
		HudMessage(s:BonusArray[BonusQueue[i]][1],s:" BONUS \cf($",d:BonusAwards[BonusQueue[i]],s:")";
			HUDMSG_FADEOUT|HUDMSG_LOG,200+i,CR_UNTRANSLATED,400.4,416.2+(8.0*i),4.0+bonuses[playernumber()],1.0);
		HudMessage(s:BonusArray[BonusQueue[i]][2];
			HUDMSG_FADEOUT|HUDMSG_LOG,300+i,CR_WHITE,400.4,432.2+(8.0*i)+(8.0*bonuses[playernumber()]),4.0+bonuses[playernumber()],1.0);
		GiveInventory("CoinItem",BonusAwards[BonusQueue[i]]);
	}
	bonuses[playernumber()]=0;
	SetFont("BigFont");
	for(i=0;i<=3;i++)
	{
		HudMessage(s:bigmessage; HUDMSG_FADEINOUT,199,CR_GOLD,400.4,392.2,0.0,0.5,0.5);
		delay(35);
	}
}

function void GetEndBonuses(int correct)
{
	if(!correct) //Patch code to save me the trouble of trying to go through all themaps to fix this.
		return;
	if(CheckInventory("CoinItem") > 30000)
		GetBonus(B_CASH30K);
	else if(CheckInventory("CoinItem") > 20000)
		GetBonus(B_CASH20K);
	else if(CheckInventory("CoinItem") > 10000)
		GetBonus(B_CASH10K);
	//log(s:"Game mode - ",i:gamemode,s:"  - Activator: ",n:playernumber()+1);
	if(GameMode==GAME_MILESTONE && CurrentMile==0)
		GetBonus(B_NOMILESTONES);
	if(GameMode==GAME_GOAL && ThingCount(T_NONE,HateEpicenter)==NumberOfTargets)
		GetBonus(B_NOGOALS);
	if(GameMode==GAME_OVERMIND && ThingCount(T_NONE,HateEpicenter)==NumberOfTargets)
		GetBonus(B_NOCORES);
	if(GameMode==GAME_CORE)
	{
		if(GetActorProperty(HateEpicenter,AProp_Health)==1000)
			GetBonus(B_CORE100);
		else if(GetActorProperty(HateEpicenter,AProp_Health)>=950 && GetActorProperty(HateEpicenter,AProp_Health)<1000)
			GetBonus(B_CORE95);
		else if(GetActorProperty(HateEpicenter,AProp_Health)>=900 && GetActorProperty(HateEpicenter,AProp_Health)<950)
			GetBonus(B_CORE90);
	}
	if(GameMode==GAME_LIMIT)
	{
		if(LimitCounter==0) // Let no demons past the deadline.
			GetBonus(B_LIMITNONE);
		else if(LimitCounter<=LimitMax/4 /*&& LimitCounter>LimitMax/2*/)
			GetBonus(B_LIMITQUARTER);
		else if(LimitCounter<=LimitMax/2)
			GetBonus(B_LIMITHALF);
	}
	if(DamageTaken[PlayerNumber()]==0) // Took no damage.
		GetBonus(B_NODAMAGE);
	else if(DamageTaken[PlayerNumber()]>=50 && DamageTaken[PlayerNumber()]<100) // Took between 50 and 99 damage.
		GetBonus(B_DAMAGE100);
	else if(DamageTaken[PlayerNumber()]<50) //Took less than 50 damage.
		GetBonus(B_DAMAGE50);
	if(GameSkill() == SKILL_VERY_HARD)
		GetBonus(B_NIGHTMARE);
	if(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]==-1) // If the map is in time attack mode.
	{
		//log(s:"Time checked");
		if(levelRunningTime<=MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]/4)
			GetBonus(B_TIMEQUARTER);
		else if(levelRunningTime<=MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]/3)
			GetBonus(B_TIMETHIRD);
		else if(levelRunningTime<=MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]/2)
			GetBonus(B_TIMEHALF);
	}
	ACS_ExecuteAlways(S_GETBONUS,0,0);
}

script S_DAMAGECHECKS ENTER
{
	int oldhealth=GetActorProperty(0,AProp_Health);
	delay(1);
	int newhealth=GetActorProperty(0,AProp_Health);
	if(newhealth<oldhealth)
		DamageTaken[PlayerNumber()]=DamageTaken[PlayerNumber()] +(oldhealth-newhealth);
	restart;
}

// Wave settings

function void WaveEnemy(int wave,str actor,int num)
{
	if(EnemyEntriesUsed==MAX_ENEMY_ENTRIES)
		PrintBold(s:"Error: EnemyEntries[] limit hit");
	EnemyEntries[EnemyEntriesUsed][0]=wave;
	EnemyEntries[EnemyEntriesUsed][1]=actor;
	EnemyEntries[EnemyEntriesUsed++][2]=num;
}

function void ClearWaveEnemies(void)
{
	EnemyEntriesUsed=0;
}

function void WaveMessage(int wave,int name,str message)
{
	if(RadioMessagesUsed==MAX_RADIO_MSGS)
		PrintBold(s:"Error: RadioMessages[] limit hit");
	RadioMessages[RadioMessagesUsed][0]=wave;
	RadioMessages[RadioMessagesUsed][1]=name;
	RadioMessages[RadioMessagesUsed++][2]=message;
}

// Removes all messages of a certain wave
function int RemoveWaveMessage(int wave)
{
	int i,j,z,found;
	for(i=0; i<RadioMessagesUsed; i++)
	{
		if(RadioMessages[i][0]==wave)
		{
			RadioMessagesUsed--;
			found++;
			for(j=i; j<RadioMessagesUsed; j++)
			{
			//	RadioMessages[j]=RadioMessages[j+1];
				for(z=0; z<RADIO_MSGS_WIDTH; z++)
					RadioMessages[j][z]=RadioMessages[j+1][z];
			}
			i--;
		}
	}
	return found;
}

function void ClearWaveMessages(void)
{
	RadioMessagesUsed=0;
}

//	This function is a little shortcut for maps to use. Good if we decide we want to change
//	the exact ending message later.
function void WaveMessageEnd(int wave,int name)
{
	WaveMessage(wave,name,"Incredible job, marine!");
	WaveMessage(wave,name,"You have successfully\ndefended this UAC\ninstallation!");
}

function void WaveWeapon(int wave,str actor)
{
	if(WeaponItemsUsed==MAX_WEAPON_ITEMS)
		PrintBold(s:"Error: WeaponItems[] limit hit");
	WeaponItems[WeaponItemsUsed][0]=wave;
	WeaponItems[WeaponItemsUsed++][1]=actor;
}

function void WavePowerup(int wave,str actor,int num)
{
	if(PowerupItemsUsed==MAX_POWERUP_ITEMS)
		PrintBold(s:"Error: PowerupItems[] limit hit");
	PowerupItems[PowerupItemsUsed][0]=wave;
	PowerupItems[PowerupItemsUsed][1]=actor;
	PowerupItems[PowerupItemsUsed++][2]=num;
}

function void WaveMedic(int wave,str actor,int num)
{
	if(MedicItemsUsed==MAX_MEDIC_ITEMS)
		PrintBold(s:"Error: MedicItems[] limit hit");
	MedicItems[MedicItemsUsed][0]=wave;
	MedicItems[MedicItemsUsed][1]=actor;
	MedicItems[MedicItemsUsed++][2]=num;
}

// Ammo Defines (used with WaveAmmo function)
#libdefine	BULLETS	1
#libdefine	SHELLS	2
#libdefine	ROCKETS	3
#libdefine	CELLS	4
#libdefine	GAS		5
#libdefine	MINES	6
function void WaveAmmo (int wave,int type,int amount)
{
	if(AmmoEntriesUsed==MAX_AMMO_ENTRIES)
		PrintBold(s:"Error: AmmoEntries[] limit hit");
	AmmoEntries[AmmoEntriesUsed][0]=wave;
	AmmoEntries[AmmoEntriesUsed][1]=type;
	AmmoEntries[AmmoEntriesUsed++][2]=amount;
}

function void ClearWaveItems (void)
{
	WeaponItemsUsed=0;
	PowerupItemsUsed=0;
	MedicItemsUsed=0;
	AmmoEntriesUsed=0;
}

function void ClearWaves (void)
{
	ClearWaveItems();
	ClearWaveMessages();
	ClearWaveEnemies();
}

function void ClearAll (void)
{
	ClearSettings();
	ClearWaves();
}

// Do stuff
function void CallWave (int wave)
{
	if((wave>0) && (wave<MAX_NORMAL_WAVES))
		WaveFinishCallback[wave]=FALSE;
	ACS_ExecuteAlways(S_CALLWAVE,0,wave);
}

function void SpawnStuff (int wave)
{
	SpawnAmmo(wave);
	SpawnPowerups(wave);
	SpawnWeapons(wave);
	SpawnMedic(wave);
}

function int SpawnAmmo (int wave)
{
	int counter;
	if(!AmmoSpotsUsed)
		return counter;
	Setup();
	int curAmmoQuota,curAmmoActorIndex,spot;
	for(int i=0; i<AmmoEntriesUsed; i++)
	{
		if(AmmoEntries[i][0]==wave)
		{
			curAmmoQuota=Multiplier(M_AMMO,AmmoEntries[i][2]);
			curAmmoActorIndex=FindAmmoActor(AmmoEntries[i][1],curAmmoQuota);
			// If we don't even have enough ammo quota in the first loop to spawn even one ammo item, spawn
			// one of the smallest size anyway. The logic is that the skill multiplier might have reduced the
			// ammo quota to less than what's needed to spawn any, but the mapper still expects some ammo
			// to be given.
			if((curAmmoActorIndex==-1) && (curAmmoQuota > 0))
				curAmmoActorIndex=FindLeastAmmoActor(AmmoEntries[i][1]);
			while(curAmmoActorIndex !=-1)
			{
				int tid=UniqueTid(4600,0);
				SpawnSpot(AmmoActorsNames[curAmmoActorIndex],AmmoSpots[spot],tid);
				int randomAngle=random(0,1.0),randomVelocity=random(0.5,0.75);
				SetActorVelocity(tid,fixedmul(randomVelocity,cos(randomAngle)),fixedmul(randomVelocity,sin(randomAngle)),random(4.0,6.0),1,0);
				Thing_ChangeTid(tid,0);
				ItemFogSpawner(AmmoSpots[spot]);
				counter++;
				if (spot==AmmoSpotsUsed-1)
					spot=0;
				else
					spot++; // Cycle through each spot
				curAmmoQuota -=AmmoActors[curAmmoActorIndex][1];
				curAmmoActorIndex=FindAmmoActor(AmmoEntries[i][1],curAmmoQuota);
			}
		}
	}
	return counter;
}

function int FindAmmoActor (int type,int amount)
{
	if(amount<=0)	// Quickly return -1 if we're given an impossible task
		return -1;
	int candidate=-1;
	for(int i=0; i<AmmoActorsUsed; i++)
	{
		if((AmmoActors[i][0]==type) && (AmmoActors[i][1]<=amount))
		{
			if(candidate==-1)
				candidate=i;
			else if(AmmoActors[i][1]>AmmoActors[candidate][1])
				candidate=i;
		}
	}
	return candidate;
}

function int FindLeastAmmoActor (int type)
{
	int candidate=-1;
	for(int i=0; i<AmmoActorsUsed; i++)
	{
		if(AmmoActors[i][0]==type)
		{
			if(candidate==-1)
				candidate=i;
			else if(AmmoActors[i][1]<AmmoActors[candidate][1])
				candidate=i;
		}
	}
	return candidate;
}

function int SpawnWeapons (int wave)
{
	int counter;
	if(! WeaponSpotsUsed)
		return counter;
	Setup();
	bool weaponsThrusted;
	for(int i=0; i<WeaponItemsUsed; i++)
	{
		if(WeaponItems[i][0]==wave)
		{
			counter++;	// Only count unique weapons spawned, not total
			if(! weaponsThrusted) // Make sure we only thrust old weapons one time
			{
				// Thrust old weapon(s) out of the way
				int randomAngle=random(0,1.0),randomVelocity=random(0.75,1.0);
				SetActorVelocity(lastWeaponTid,fixedmul(randomVelocity,cos(randomAngle)),fixedmul(randomVelocity,sin(randomAngle)),random(6.0,7.5),1,0);
				// Clear its TID so next weapons spawned can use it.
				Thing_ChangeTID(lastWeaponTid,0);
				weaponsThrusted=TRUE;
			}
			for (int spot=0; spot<WeaponSpotsUsed; spot++)
			{
				// Spawn new weapon
				SpawnSpot(WeaponItems[i][1],WeaponSpots[spot],lastWeaponTid);
				ItemFogSpawner(WeaponSpots[spot]);
			}
		}
	}
	// This next line makes sure the weapons stay if "Weapons Stay" is set or the game is coop
	SetActorProperty(lastWeaponTid,APROP_Dropped,FALSE);
	return counter;
}

function int SpawnPowerups (int wave)
{
	int counter;
	if(! PowerupSpotsUsed)
		return counter;
	int spot;
	for(int i=0; i<PowerupItemsUsed; i++)
	{
		if(PowerupItems[i][0]==wave)
		{
			while(ThingCountName(PowerupItems[i][1],0) < Multiplier(M_POWERUP,PowerupItems[i][2]))
			{
				int tid=UniqueTid(4600,0);
				SpawnSpot(PowerupItems[i][1],PowerupSpots[spot],tid);
				int randomAngle=random(0,1.0),randomVelocity=random(0.5,0.75);
				SetActorVelocity(tid,fixedmul(randomVelocity,cos(randomAngle)),fixedmul(randomVelocity,sin(randomAngle)),random(4.0,6.0),1,0);
				Thing_ChangeTid(tid,0);
				ItemFogSpawner(PowerupSpots[spot]);
				counter++;
				if (spot==PowerupSpotsUsed-1)
					spot=0;
				else
					spot++; // Cycle through each spot
			}
		}
	}
	return counter;
}

// This function works identical to SpawnPowerups()
function int SpawnMedic (int wave)
{
	int counter;
	if(! MedicSpotsUsed)
		return counter;
	int spot;
	for(int i=0; i<MedicItemsUsed; i++)
	{
		if(MedicItems[i][0]==wave)
		{
			while(ThingCountName(MedicItems[i][1],0) < Multiplier(M_MEDIC,MedicItems[i][2]))
			{
				int tid=UniqueTid(4600,0);
				SpawnSpot(MedicItems[i][1],MedicSpots[spot],tid);
				int randomAngle=random(0,1.0),randomVelocity=random(0.5,0.75);
				SetActorVelocity(tid,fixedmul(randomVelocity,cos(randomAngle)),fixedmul(randomVelocity,sin(randomAngle)),random(4.0,6.0),1,0);
				Thing_ChangeTid(tid,0);
				ItemFogSpawner(MedicSpots[spot]);
				counter++;
				if (spot==MedicSpotsUsed-1)
					spot=0;
				else
					spot++; // Cycle through each spot
			}
		}
	}
	return counter;
}

// Note: ItemFogSpawner can only work on one thing at a time! Don't give it a tid of multiple things.
function void ItemFogSpawner(int spot)
{
	// Have we called ItemFogSpawner for this same spot not too long ago?
	// If so, do nothing and return out of the function.
	for(int i=0; i<ITEMFOG_CACHE_LEN; i++)
		if(ItemFogCache[i][0]==spot && (Timer() - ItemFogCache[i][1]) < ITEMFOG_REQUIRED_TIC_DIF)
			return;
	ItemFogCache[ItemFogCacheLoc][0]=spot;
	ItemFogCache[ItemFogCacheLoc++][1]=Timer();
	if(ItemFogCacheLoc==ITEMFOG_CACHE_LEN)
		ItemFogCacheLoc=0;
	Spawn("ItemFog",GetActorX(Spot)+random(-8.0,8.0),GetActorY(Spot)+random(-8.0,8.0),GetActorZ(Spot)+random(8.0,16.0),0,0);
	ThingSound(spot,"misc/spawn",127); // lovely flange
}

// Internal, probably shouldn't be called by a map directly
function void GiveMapRewards (void)
{
	for(int i=0; i<=highestPlayerNumber; i++)
	{
		for(int j=0; j<MapRewardsUsed; j++)
			GiveActorInventory(PLAYER_TID_START+i,MapRewards[j][0],MapRewards[j][1]);
	}
}

function void AnnounceNewWave (int wave)
{
	if((wave>0)&&(wave<=Waves)) // Don't announce for special negative waves or post-final wave
	{
		curWave=wave;
		UpdateWaveTrackers();
		UpdateTime();
		SetHudSize(512,384,1);
		SetFont("BigFont");
		if(wave==Waves)
			wave=0;	 // Index 0 points to "Final"
		if(wave<21)
			HudmessageBold(s:WaveNumber[wave][0],s:"\cc Wave!";
				HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_RED,256.0,128.1,3.0,1.0,1.0);
		else
			HudMessageBold(s:"Wave ",d:wave,s:"\cc!";
				HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_RED,256.0,128.1,3.0,1.0,1.0);
		if(wave<20)
			AmbientSound(WaveNumber[wave][1],127);
	}
}

function void AnnounceWaveDone (int wave)
{
	if(DisableAnnounceWaveDone)
		return;
	if((wave>0)&&(wave<=Waves)) // Don't announce for special negative waves or post-final wave
	{
		SetHudSize(512,384,1);
		SetFont("BigFont");
		if(wave==Waves)
			wave=0;	 // Index 0 points to "Final"
		if(wave<21)
			HudmessageBold(s:WaveNumber[wave][0],s:" Wave \ccComplete!";
				HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_RED,256.0,128.1,3.0,1.0,1.0);
		else
			HudmessageBold(s:"Wave ",d:wave,s:" \ccComplete!";
				HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_RED,256.0,128.1,3.0,1.0,1.0);
		AmbientSound("T_WAVDON",127);
	}
}

function void AnnounceNewMile (int mile)
{
	SetHudSize(640,480,1);
	SetFont("BigFont");
	if(mile<21)
		HudmessageBold(s:WaveNumber[mile][0],s:" Milestone \cchas been breached!";
			HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_BLACK,320.0,130.1,3.0,1.0,1.0);
	else
		HudmessageBold(s:"Milestone ",d:mile,s:" \cchas been breached!";
			HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_BLACK,320.0,130.1,3.0,1.0,1.0);
	if(mile<MILE_ANNOUNCE_SOUNDS_LEN)
		AmbientSound(MileAnnounceSounds[mile],127);
}

function int RandomCoords (int zone,int axis)	// 0 is x, 1 is y, 2 is z
{
	int result;
	switch (axis)
	{
	case 0:
		result=random(ZoneData[zone][0],ZoneData[zone][0]+ZoneData[zone][2]); // origin x, origin x + xlength
		break;
	case 1:
		result=random(ZoneData[zone][1],ZoneData[zone][1]+ZoneData[zone][3]); // origin y, origin y + yheight
		break;
	case 2:
		result=random(ZoneData[zone][4],ZoneData[zone][4]+ZoneData[zone][7]); // floor z, floor z + zheight
		break;
	default:
		PrintBold(s:"Error: RandomCoords() called without a valid axis");
	}
	return result;
}

function void GiveDefaults (int tid,int patrolnode,int hatetarget)
{
	Thing_SetGoal(tid,patrolnode,0,1);
	if(hatetarget)
		Thing_Hate(tid,hatetarget,3);
}

function void UpdateJailTrackers (void)
{
	int inJail,i,curTrackers;
	// Count how many players are in jail
	for(i=0; i<=highestPlayerNumber; i++)
		inJail +=CheckActorInventory(PLAYER_TID_START+i,"JailTracker");
	for(i=0; i<=highestPlayerNumber; i++)
	{
		curTrackers=CheckActorInventory(PLAYER_TID_START+i,"JailTrackerAllPlayers");
		if(curTrackers<inJail)
			GiveActorInventory(PLAYER_TID_START+i,"JailTrackerAllPlayers",inJail-curTrackers);
		else if(curTrackers>inJail)
			TakeActorInventory(PLAYER_TID_START+i,"JailTrackerAllPlayers",curTrackers-inJail);
	}
}

function bool mapRangeFinished (int first,int last)
{
	for(int i=first; i<=last; i++)
	{
		if(MapScores[i]==0) // Map isn't finished
			return false;
	}
	return true;
}

str prisoncams[6]={"CT_1","CT_2","CT_3","CT_4","CT_5","CT_6"};
function void Setup (void)
{
	if(!isSetup)
	{
		isSetup=TRUE;
		lastWeaponTid=UniqueTid(4600,0);
		MonstersTid=UniqueTid(4700,0);
		randomRadioFace=random(0,LEN_RADIO-1);
		if(PrisonCamStart)
			for(int i=0;i<=5;i++)
				SetCameraToTexture(PrisonCamStart+i,prisoncams[i],90);
		if(PrisonTeleporterLineId)
		{
			SetLineSpecial(PrisonTeleporterLineId,ACS_ExecuteAlways,S_JAIL_LEAVE,0,PrisonTeleporterThrustAngle);
			SetJailTeleporter(FALSE);
		}
		AddMapReward("CoinItem",MapCoinReward[GetLevelInfo(LEVELINFO_LEVELNUM)]);
		if (MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]==-1)
			setParTime(MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)],0);
		else if (MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)] > 0)
			setParTime(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]/35,1);
	}
}

// This function applies the multiplier for the given type to amount, and returns the result.
// It handles fixed point conversion and making sure the result is rounded nicely.
// Also, if given a negative amount, it will return it positive and unmultiplied
function int Multiplier (int type,int amount)
{
	if(amount < 0)
		return 0 - amount;
	int result=amount * RawMultiplier(type);
	if((result>0.0) && (result<1.0))	// Make sure our answer is at least one
		result=1;
	else
		result=result / 1.0;		// Make result an integer
	return result;
}

int SkillScaler[5] =	{ 0.75,0.75,1.0,1.5,2.0 };

// This function returns the multiplier as a fixed point value.
// If the multiplier needs to be tweaked, this is the function to do it in.
function int RawMultiplier (int type)
{
	int result = 1.0;
	switch(type)
	{
	case M_POWERUP:
		result = 1.0*PlayerCount();
		break;
	case M_MEDIC:
	case M_AMMO:
		If(TimeAttackMode)
		result = 0.33 + 1.18*PlayerCount();	// Slightly above 1.5 for one player to account for rounding errors
		else
		result = 0.1 + 1.11*PlayerCount();	// Slightly above 1.2 for one player to account for rounding errors
		break;
	case M_ENEMIES:
	case M_BOSSHEALTH:
		If(TimeAttackMode)
			result = FixedMul(0.55 + 0.96*PlayerCount(),SkillScaler[GameSkill()]);
		else
			result = FixedMul(0.05 + 0.96*PlayerCount(),SkillScaler[GameSkill()]);
		break;
	default:
		PrintBold(s:"Error: Function Multiplier() called without a valid type argument");
	}
	return result;
}

function void ScreenFadeOut (int inTime) // time is a float value in seconds
{
	SetFont("BLACK");
	SetHudSize(4,4,1);
	HudMessageBold (s:"a"; HUDMSG_FADEINOUT,FadeOutHID,CR_UNTRANSLATED,2.0,2.0,1000.0,inTime,1.0);
	SetHudSize(0,0,0);
}

/* ******* **
** Scripts **
** ******* */

script S_MISSION_COMPLETE (void)
{
	Setup();
	if(GameActive)
	{
		bool newRecord,MapCompleted;
		SetPlayerProperty(1,2,PROP_INVULNERABILITY);
		// Set the player invulverable so he can't die after winning the game
		SetActorProperty(HateEpicenter,APROP_Invulnerable,true);
		  // Core is made invulnerable so it can't be destroyed after winning.
		// Jimmy: I really butchered this script. Sorry about that. :S
		if(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]==0)
		{
			MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]=-1;
			MapCompleted=true;
		}
		else if(levelRunningTime<MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]*35)
			newRecord=true;
		GameActive=FALSE;
		StopTimer();
		SetMusic("");
		AmbientSound("TB_VICT",127);
		GameVictory=TRUE;
		TimeAttackMode=FALSE;
		SetHudSize (640,480,1);
		SetFont("HUDMC");
		HudMessageBold (s:"a"; HUDMSG_FADEINOUT,EndMessageHID,CR_UNTRANSLATED,320.0,240.0,4.0,0.5,0.5);
		delay(3*35);
		ScreenFadeOut(3.0);
		delay(5*35);
		if (!MapCompleted) // If the player has been playing in time attack mode.
		{
			SetPlayerProperty(1,true,PROP_TOTALLYFROZEN);
			SetHudSize (480,360,1);
			SetFont("BigFont");
			int lseconds=(levelRunningTime/35)%60;
			int lminutes=(levelRunningTime/35)/60;
			HudMessageBold(s:"Time Taken: \cg",s:zerospace(lminutes,2),d:lminutes,s:":",s:zerospace(lseconds,2),d:lseconds;
				HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_WHITE,240.0,120.1,7.0,1.5,1.0);
			//delay(35/2);
			int mseconds=MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]%60;
			int mminutes=MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]/60;
			HudMessageBold(s:"Par Time: \cg",s:zerospace(mminutes,2),d:mminutes,s:":",s:zerospace(mseconds,2),d:mseconds;
				HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_WHITE,240.0,160.1,7.0,1.5,1.0);
			if(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)] !=0)
			{
				int bseconds=(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]/35)%60;
				int bminutes=(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]/35)/60;
				HudMessageBold(s:"Best Time: \cg",s:zerospace(bminutes,2),d:bminutes,s:":",s:zerospace(bseconds,2),d:bseconds;
					HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_WHITE,240.0,200.1,7.0,1.5,1.0);
			}
			if(newRecord)
			{
				MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]=levelRunningTime;
				//Log(s:"Extra Credit: ",d:(MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]-(levelRunningTime/35))*10);
				GiveInventory("CoinItem",(MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]-(levelRunningTime/35))*10);
				HudMessageBold(s:"A new record!";
					HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_GREEN,240.0,240.1,6.0,2.5,1.0);
			}
			else
			{
				MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)] = MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)];
				HudMessageBold(s:"Record not beaten";
					HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_ORANGE,240.0,240.1,6.0,2.5,1.0);
			}
			delay(10*35);
			HudMessageBold(s:"Hard Mode Completed!";
				HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_GREEN,240.0,160.1,6.0,2.5,1.0);
			delay(10*35);
			SetPlayerProperty(1,false,PROP_TOTALLYFROZEN);
		}
		SetPlayerProperty(1,false,PROP_INVULNERABILITY);
		GiveMapRewards();
		if(GetLevelInfo(LEVELINFO_LEVELNUM)==35)
			Exit_Secret(ExitPos);
		else
			Exit_Normal(ExitPos);
	}
}

// Placed on lines so living, enemy monsters can cause the mission to fail
script S_M_ACTIVATE_FAIL(int shopitem)
{
	if(GetLevelInfo(LEVELINFO_LEVELNUM)==999)
		ACS_NamedExecuteAlways("Shop",0,shopitem);
	// Don't continue if the activator is a dead monster or friendly
	else if(GameActive &&
		((ClassifyActor(0) & (ACTOR_MONSTER | ACTOR_DEAD)) !=(ACTOR_MONSTER | ACTOR_DEAD)) &&
		(!GetActorProperty(0,APROP_Friendly)))
		ACS_Execute(S_MISSION_FAIL,0,0);
}

script S_MISSION_FAIL (void)
{
	if(!GameActive)
		Terminate;
	GameActive=FALSE;
	TimeAttackMode=FALSE;
	StopTimer();
	SetMusic("");
	AmbientSound("TB_LOST",127);
	SetHudSize(640,480,1);
	/*if(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]==-1)
		SetFont("HUDTH");
	else*/
		SetFont("HUDGO");
	HudMessageBold(s:"a"; HUDMSG_FADEINOUT,EndMessageHID,CR_UNTRANSLATED,320.0,240.0,5.0,0.5,0.5);
	ScreenFadeOut(5.0);
	delay(35 * 3);
	AmbientSound("T_FAIL",127); // "You have failed to defend your Stronghold"
	delay(35 * 4);
	Exit_Secret(ExitPos);
}

script S_DEADLINE(void)
{
	if(BreakTime==-1)	// Default setting
		BreakTime=3*35;
	StartTimer();
	int ThisWave;
	for(ThisWave=1; ThisWave<=Waves; ThisWave++)
	{
		if(!F_CallNextWave)
			CallWave(ThisWave);
		while(! WaveFinishCallback[ThisWave] && !F_CallNextWave)
			delay(1);
		if(ThisWave==Waves)
		{
			StopTimer();		// Stop timer soon as last wave is over
		    BreakTime=3*35; // Added by Jimmy.
			// It allows players to read the last wavemessages on maps with high BreakTime (such as most limit maps).
		}
		if(F_CallNextWave)
		{
			//WaveFinishCallback[ThisWave]=TRUE;
			delay(BreakTime);
			if(F_CallNextWave > 1 &&(F_CallNextWave - 1) + ThisWave < Waves)
				ThisWave +=(F_CallNextWave - 1);
			Else If(F_CallNextWave > 1 &&(F_CallNextWave - 1) + ThisWave >=Waves)
			{
				acs_execute(S_MISSION_COMPLETE,0,0,0,0);
				terminate;
			}
			if(F_CallNextWave < 0 &&(F_CallNextWave) + ThisWave >=1)
				ThisWave +=(F_CallNextWave);
			Else If(F_CallNextWave < 0 &&(F_CallNextWave) + ThisWave <=0)
				ThisWave=0;
			F_CallNextWave=0;
		}
		else
		Delay(5*35);
	}
	StopTimer();
	// Call the last wave, to spawn maybe extra items, do a special map action, or a message, but don't wait on it.
	CallWave(ThisWave);
	Delay(3*35);	// Wait a moment before ending the script, so the ending screen or whatever the map does next
			// isn't too immediate.
}

script S_CORE_GAME(void)
{
	if(BreakTime == -1)	// Default setting
		BreakTime=6*35;
	GameMode=GAME_CORE;
	HealthWatch(HateEpicenter,GetActorProperty(HateEpicenter,APROP_SpawnHealth),S_MISSION_FAIL,WATCH_CORE);
	ACS_ExecuteWait(S_DEADLINE,0,0);
}

#define	MAX_WATCH_SLOTS	3
int WatchSlot[MAX_WATCH_SLOTS];

function int reserveOpenWatchSlot(void)
{
	for(int i=0; i<MAX_WATCH_SLOTS; i++)
	{
		if(!WatchSlot[i])
		{
			WatchSlot[i]=TRUE;
			return i;
		}
	}
	PrintBold(s:"Error: Out of Watch Slots");
	return 0;
}

function void ClearWatchHUD(int offset)
{
	HudMessageBold(s:""; HUDMSG_PLAIN,CoreLabelHID+CoreHIDOffset*offset,CR_UNTRANSLATED,0.0,0.0,0.1);
	HudMessageBold(s:""; HUDMSG_PLAIN,CoreGraphicHID+CoreHIDOffset*offset,CR_UNTRANSLATED,0.0,0.0,0.1);
	HudMessageBold(s:""; HUDMSG_PLAIN,CorePercentHID+CoreHIDOffset*offset,CR_UNTRANSLATED,0.0,0.0,0.1);
	WatchSlot[offset]=FALSE;
}

function void WatchTitle(int type,int offset)
{
	str name="Unknown",graphic="HUDGFXC";
	// Names
	switch(type)
	{
	case WATCH_CORE:
		name="Core";
		break;
	case WATCH_BOSS:
		name="Boss";
		graphic="HUDBOSS";
		break;
	case WATCH_BOSSTARGET:
		name="Targets";
		graphic="HUDGFXC2";
		break;
	case WATCH_LIMIT:
		name="Limit";
		graphic="HUDDEMON";
		break;
	case WATCH_GOALS:
		name="Goals";
		graphic="HUDTRGT";
		break;
	}
	SetHudSize(640,430,0);
	SetFont("SMALLFONT");
	HudMessageBold(s:name; HUDMSG_PLAIN,CoreLabelHID+CoreHIDOffset*offset,CR_GRAY,
	CoreLabelX,CoreLabelY+CoreYOffset*offset,0.0);
	SetFont(graphic);
	HudMessageBold(s:"a"; HUDMSG_PLAIN,CoreGraphicHID+CoreHIDOffset*offset,CR_UNTRANSLATED,
	CoreGraphicX,CoreGraphicY+CoreYOffset*offset,0.0);
	SetHudSize(0,0,0);	// Reset this so the calling script is back to the defaults
}

function void WatchAnnounceChange(int type,int value,int maxnum)
{
	// Jump out now if we know we're doing nothing.
	if(type==WATCH_CORE||type==WATCH_BOSS||type==WATCH_GOALS)
		return;
	SetFont("SMALLFONT");
	switch(type)
	{
	case WATCH_BOSSTARGET:
		if(value==maxnum)	// Don't announce when we have all cores still left
			break;
		AmbientSound("amb16",127);
		if(value==0)
			PrintBold(s:"\cgAll \cccores have been destroyed!");
		else
			PrintBold(s:"\cg",d:value,s:" / ",d:maxnum,s:" \cccores remaining!");
		break;
	case WATCH_LIMIT:
		if(value > 0)
			PrintBold(s:"\cg",d:value,s:" / ",d:maxnum,s:"\cc have made it through!");
		break;
	}
//	SetHudSize(WatchHudSizeX,WatchHudSizeY,0);
	SetFont("BIGFONT");
}

// Scripts can't have strings passed to them, so handle the string in a wrapper function
function void HealthWatch(int tid,int maxhealth,int deadscript,int type)
{
	int offset=reserveOpenWatchSlot();
	WatchTitle(type,offset);
	ACS_Execute(S_HEALTH_WATCH,0,tid,maxhealth,deadscript |(offset<<12) |(type<<16));
}

script S_HEALTH_WATCH(int tid,int maxhealth,int data)
{
	int deadscript=(data&0x00000FFF),offset=(data&0x0000F000)>>12,type=(data&0x000F0000)>>16,color,curpercent;
	SetHudSize(WatchHudSizeX,WatchHudSizeY,0);
	SetFont("BIGFONT");
	while(true)
	{
		curpercent=GetPercent(GetActorProperty(tid,APROP_Health),maxhealth);
		if(GameMode==GAME_CORE)
			color=GetPercentColorCore(curpercent);
		else
			color=GetPercentColor(curpercent);
		HudMessageBold(d:curpercent,s:"%";
			HUDMSG_PLAIN,CorePercentHID+CoreHIDOffset*offset,color,CorePercentX,CorePercentY+CoreYOffset*offset,0.0);
		WatchAnnounceChange(type,curpercent,100);
		if(GetActorProperty(tid,APROP_HEALTH) <=0)
			break;
		delay(15);
		// We don't need to update the screen until the health changes enough to change the
		// actual percent display value
		while(GetPercent(GetActorProperty(tid,APROP_HEALTH),maxhealth)==curpercent)
			delay(5);
	}
	delay(45);
	if(deadscript)
		ACS_Execute(deadscript,0,0);
	delay(5*35 + 10); // A bit over 5 seconds
	ClearWatchHUD(offset);
}

// Scripts can't have strings passed to them, so handle the string in a wrapper function
function void CountWatch(int tid,int maxnum,int deadscript,int type)
{
	int offset=reserveOpenWatchSlot();
	WatchTitle(type,offset);
	ACS_Execute(S_COUNT_WATCH,0,tid,maxnum,deadscript |(offset<<12) |(type<<16));
}

script S_COUNT_WATCH(int tid,int maxnum,int data)
{
	int deadscript=(data&0x00000FFF),offset=(data&0x0000F000)>>12,type=(data&0x000F0000)>>16,
	color,curcount;
	SetHudSize(WatchHudSizeX,WatchHudSizeY,0);
	SetFont("BIGFONT");
	while(true)
	{
		curcount=ThingCount(T_NONE,tid);
		color=GetPercentColor(GetPercent(curcount,maxnum));
		HudMessageBold(d:curcount,s:"/",d:maxnum;
			HUDMSG_PLAIN,CorePercentHID+CoreHIDOffset*offset,color,CorePercentX-15.2,CorePercentY+CoreYOffset*offset,0.0);
		WatchAnnounceChange(type,curcount,maxnum);
		if(curcount <=0)
			break;
		delay(5);
		// We don't need to update the screen until the count changes
		while(ThingCount(T_NONE,tid)==curcount)
			delay(5);
	}
	delay(45);
	if(deadscript)
		ACS_Execute(deadscript,0,0);
	delay(5*35 + 10); // A bit over 5 seconds
	ClearWatchHUD(offset);
}

// Scripts can't have strings passed to them, so handle the string in a wrapper function
function void LimitWatch(int maxnum,int deadscript,int type)
{
	int offset=reserveOpenWatchSlot();
	WatchTitle(type,offset);
	ACS_Execute(S_LIMIT_WATCH,0,maxnum,deadscript |(offset<<12) |(type<<16));
}

script S_LIMIT_WATCH(int maxnum,int data)
{
	int deadscript=(data&0x00000FFF),offset=(data&0x0000F000)>>12,type=(data&0x000F0000)>>16,
	color,curcount;

	SetHudSize(WatchHudSizeX,WatchHudSizeY,0);
	SetFont("BIGFONT");
	while(true)
	{
		curcount=LimitCounter;
		// We want the color to match the percent of limits not reached yet
		color=GetPercentColor(GetPercent(maxnum-curcount,maxnum));
		HudMessageBold(d:curcount,s:"/",d:maxnum;
			HUDMSG_PLAIN,CorePercentHID+CoreHIDOffset*offset,color,CorePercentX-38.1,CorePercentY+CoreYOffset*offset,0.0);
		WatchAnnounceChange(type,curcount,maxnum);
		if(curcount >=maxnum)
			break;
		// We don't need to update the screen until the count changes
		while(LimitCounter==curcount)
			delay(1);
	}
	delay(45);
	if(deadscript)
		ACS_Execute(deadscript,0,0);
	delay(5*35 + 10); // A bit over 5 seconds
	ClearWatchHUD(offset);
}

script S_MILESTONE(void)
{
	GameMode=GAME_MILESTONE;
	if(BreakTime == -1)	// Default setting
		BreakTime=9*35;
	ACS_ExecuteWait(S_DEADLINE,0,0);
}

script S_LIMIT_GAME(void)
{
	GameMode=GAME_LIMIT;
	if(BreakTime==-1)	// Default setting
		BreakTime=12*35;
	LimitCounter=0;
	LimitWatch(LimitMax,S_MISSION_FAIL,WATCH_LIMIT);
	ACS_ExecuteWait(S_DEADLINE,0,0);
}

script S_OVERMIND(void)
{
	// Set up boss monster
	GameMode = GAME_OVERMIND;
	Thing_Activate(BossMonster);
	Thing_Hate(BossMonster,BossTarget,2);
	int OriginalHealth = GetActorProperty(BossMonster,APROP_HEALTH);
	NumberOfTargets = ThingCount( T_NONE,BossTarget );
	HealthWatch(BossMonster,OriginalHealth,S_OVERMIND_COMPLETE,WATCH_BOSS);
	CountWatch(BossTarget,ThingCount(T_NONE,BossTarget),S_MISSION_FAIL,WATCH_BOSSTARGET);
	DisableAnnounceWaveDone=TRUE;
	StartTimer();
	for(int i=1; i<=Waves; i++)
	{
		CallWave(i);
		Delay(4*35);
		while(GetActorProperty(BossMonster,APROP_Health) > OriginalHealth *(Waves-i) / Waves)
			delay(5);
	}
	Suspend;
	// Gameplay control continues in S_OVERMIND_COMPLETE.
	// This script left suspended so that it can be terminated later, and level control continues.
}

script S_OVERMIND_COMPLETE(void)
{
	if(MonstersTid)
		Thing_Damage(MonstersTid,INT_MAX);
	GameFinishing=TRUE;	// Stop all running waves
	ACS_Suspend(S_OVERMIND,0);	// Pause Overmind script so it doesn't continue launching waves
	StopTimer();
	// Call the last wave, to spawn maybe extra items, do a special map action, or a message, but don't wait on it.
	CallWave(Waves+1);
	Delay(3*35);	// Wait a moment before ending the script, so the ending screen or whatever the map does next
			// isn't too immediate.
	ACS_Terminate(S_OVERMIND,0);
}

script S_MILE_MARKER(int mile)
{
	if(mile==0)
		// There's no reason to call this script with mile==0, so this was most likely
		// a mapping error.
		PrintBold(s:"Error: S_MILE_MARKER script #250 called with argument 0");
	// Don't continue if the activator is a dead monster or friendly
	if((mile>CurrentMile) &&
		((ClassifyActor(0) &(ACTOR_MONSTER | ACTOR_DEAD)) !=(ACTOR_MONSTER | ACTOR_DEAD)) &&
		(!GetActorProperty(0,APROP_Friendly)))
	{
		AnnounceNewMile(mile);
		if(MileScript)
		{
			// A milestone might've possibly been skipped. Bad level design? Maybe.
			// But let's execute the MileScript for each time
			for(int i=CurrentMile+1; i<=mile; i++)
			{
				// Delay between calling scripts so that they're called in the right order.
				// No need to delay on the first iteration.
				if(i !=CurrentMile+1)
					delay(1);
				ACS_ExecuteAlways(MileScript,0,i);
			}
		}
		CurrentMile=mile;
	}
}

script S_LIMIT_MARKER(void)
{
	// Don't continue if the activator is a dead monster or friendly
	if(GameActive &&
		((ClassifyActor(0) & ACTOR_MONSTER)==ACTOR_MONSTER) &&
		((ClassifyActor(0) &(ACTOR_MONSTER | ACTOR_DEAD)) !=(ACTOR_MONSTER | ACTOR_DEAD)) &&
		(!GetActorProperty(0,APROP_Friendly)))
	{
		Spawn("TeleportFog",GetActorX(0)+random(-8.0,8.0),GetActorY(0)+random(-8.0,8.0),GetActorZ(0)+random(8.0,16.0));
		Thing_Remove(0);
		LimitCounter++;
	}
}

script S_GOAL_GAME(void)
{
	GameMode=GAME_GOAL;
	CountWatch(HateEpicenter,ThingCount(T_NONE,HateEpicenter),S_MISSION_FAIL,WATCH_GOALS);
	NumberOfTargets=ThingCount(T_NONE,HateEpicenter);
	ACS_ExecuteWait(S_DEADLINE,0,0);
}

script S_GOAL_DESTROYED(int color)
{
	switch(color)
	{
	case GOAL_RED:
		printbold(s:"\cARed \cGGoal has been destroyed!");
		break;
	case GOAL_ORANGE:
		printbold(s:"\cIOrange \cGGoal has been destroyed!");
		break;
	case GOAL_BLUE:
		printbold(s:"\cHBlue \cGGoal has been destroyed!");
		break;
	case GOAL_GREEN:
		printbold(s:"\cDGreen \cGGoal has been destroyed!");
		break;
	case GOAL_WHITE:
		printbold(s:"\cJWhite \cGGoal has been destroyed!");
		break;
	default:
		printbold(s:"Error: Invalid goal color");
		Terminate;
	}
	if(GoalScript)
		ACS_ExecuteAlways(GoalScript,0,ThingCount(T_NONE,HateEpicenter));
}

script S_CORE_WARNINGS(int healthleft)
{
	SetHudSize(640,480,1);
	SetFont("BigFont");
	switch(healthleft)
	{
	case 1:
		HudmessageBold(s:"Core \ccis under attack!";
		HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_GREEN,320.0,130.1,3.0,0.0,1.0);
		AmbientSound("T_CRATTK",128);
		break;
	case 2:
		HudmessageBold(s:"Core \ccis sustaining damage!";
		HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_YELLOW,320.0,130.1,3.0,0.0,1.0);
		AmbientSound("T_CRHEVY",128);
		break;
	case 3:
		HudmessageBold(s:"Core \ccis reaching critical mass!";
		HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_RED,320.0,130.1,3.0,0.0,1.0);
		AmbientSound("T_CRUNST",128);
		break;
	case 4:
		HudmessageBold(s:"Core \cchas been destroyed!";
		HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_BLACK,320.0,130.1,3.0,0.0,1.0);
		AmbientSound("T_CRDEST",128);
	}
	delay(35*4);
}

function int GetPercent(int value,int maxval)
{
	int candidate=(value*100)/maxval;
	// Check if we rounded down to zero; return at least 1 if we did
	if(candidate==0&&value>0)
		return 1;
	// Don't give a negative percent
	return max(candidate,0);
}

function int GetPercentColor(int percent)
{
	if(percent > 75)
		return CR_GREEN;
	else if(percent <=75 && percent > 50)
		return CR_YELLOW;
	else if(percent <=50 && percent > 25)
		return CR_ORANGE;
	return CR_RED;
}

function int GetPercentColorCore(int percent)
{
	if(percent > 66)
		return CR_GREEN;
	else if(percent <=66 && percent > 33)
		return CR_YELLOW;
	return CR_RED;
}

// Don't call this script directly, use CallWave() function
// This is so that the WaveFinishCallback can be set to false synchronously, so that way it can be
// waited on.
script S_CALLWAVE(int wave)
{
	Setup();
	if(EventScript)
		ACS_ExecuteAlways(EventScript,0,wave);
	Delay(3);	// Not only a slight pause, but lets the EventScript make changes first.
			// Called even when there isn't an EventScript just for consistency.
	SpawnStuff(wave);
	// Give player time to grab items before wave messages and enemies spawn.
	Delay(BreakTime);
	AnnounceNewWave(wave);
	ACS_ExecuteAlways(S_MESSAGE,0,wave);
	Delay(5*35);
	// Monster spawning
	if(ZoneDataUsed)
	{
		int cacheUsed,cacheId=EnemySpawnCacheLoc++;
		if(EnemySpawnCacheLoc==ENEMY_SPAWN_CACHE_LEN)
			EnemySpawnCacheLoc=0;
		// Load all monsters to spawn this wave into EnemySpawnCache[cacheId]
		for(int i=0; i<EnemyEntriesUsed; i++)
		{
			if(EnemyEntries[i][0]==wave)
				// Every monster instance is given its own slot inside the EnemySpawnCache
				for(int j=0; j<Multiplier(M_ENEMIES,EnemyEntries[i][2]); j++)
					EnemySpawnCache[cacheId][cacheUsed++]=EnemyEntries[i][1];
		}
		if(cacheUsed>MAX_ENEMIES_PER_WAVE)
		{
			PrintBold(s:"Error: Wave ",d:wave,s:" exceeds MAX_ENEMIES_PER_WAVE");
			cacheUsed=MAX_ENEMIES_PER_WAVE;
		}
		int cacheUsedCounter=cacheUsed,curEnemyId,curEnemyName,spawned,zone=PickZone(CurrentMile);
		// While we still have monsters left to spawn, spawn them
		while(cacheUsedCounter > 0)
		{
			spawned=FALSE;
			curEnemyId=random(0,cacheUsedCounter-1);
			for(int k=0; k <=curEnemyId; k++)
			{
				// Every time we hit a null entry, skip over it and pretend we didn't
				// see it.
				//	Q: Why not just pick the entry first, check if it's null,
				//	and then just go forward to the next non-null one?
				//	A: If we did that, then a monster entry proceeding a series of
				//	nulls would have a higher chance of being picked than others.
				if(EnemySpawnCache[cacheId][k]=="NULL")
					curEnemyId++;
			}
		// We want to repeatedly try to spawn the monster until it has spawned.
		// Note that while attempting to spawn the monster, no monsters spawn
		// at other zones. Not sure if this is worth fixing or to be considered
		// a gameplay "feature".
		//	Possible solutions:
		//	* If monster doesn't spawn, try to spawn at next zone.
		//		- One zone can have (possibly significantly) more monsters spawned.
		//	* Split up EnemySpawnCache between zones, and give each zone its own
		//	thread/script to control its spawning.
		//		- A zone can take longer to spawn its monsters than other zones.
			while(!spawned)
			{
				if(!GameActive||GameFinishing||F_CallNextWave)
					Terminate;
				int tid=UniqueTid(4600,0);
				spawned=Spawn(EnemySpawnCache[cacheId][curEnemyId],
					RandomCoords(zone,0),RandomCoords(zone,1),
					RandomCoords(zone,2),tid,ZoneData[zone][6]);
				if(spawned)
				{
					SpawnSpot("TeleportFog",tid);
					// If the zone has no second patrol, or random==TRUE, pick first patrol
					if((!ZoneData[zone][11]) ||(random(0,1)))
						GiveDefaults(tid,ZoneData[zone][5],HateEpicenter);
					else
						GiveDefaults(tid,ZoneData[zone][11],HateEpicenter);
					Thing_ChangeTID(tid,MonstersTid);
				}
				if(TimeAttackMode) //Variable name is outdated, but it's not worth the trouble to change it.
					delay(Random(0,tics_between_monster_spawns));
				else
					delay(tics_between_monster_spawns);
			}
			// Remove the enemy just spawned from the cache
			EnemySpawnCache[cacheId][curEnemyId]="NULL";
			cacheUsedCounter--;
			zone=GetNextZone(zone,CurrentMile); // Cycle through each zone
		}
	Thing_ChangeTID(tid,0);
	}
	// Wait until all monsters are dead or if the next level cheat is called
	while(GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)-GetLevelInfo(LEVELINFO_KILLED_MONSTERS) > 0)
		delay(1);
	AnnounceWaveDone(wave);
	WaveFinished(wave);
}

function void WaveFinished(int wave)
{
	if((wave>0) &&(wave<MAX_NORMAL_WAVES))
		WaveFinishCallback[wave]=TRUE;
}

// Pick the first zone that is for the current mile
function int PickZone(int mile)
{
	int candidate=-1;
	for(int i=0; i<ZoneDataUsed&&candidate<0; i++)
	{
		if(ZoneData[i][10]==mile)
			candidate=i;
	}
	if(candidate==-1)
	{
		PrintBold(s:"Error: No zones for mile ",d:mile);
		return 0;
	}
	return candidate;
}

function int GetNextZone(int curZone,int mile)
{
	int candidate=-1;
	for(int i=curZone+1; i<ZoneDataUsed; i++)
	{
		if(ZoneData[i][10]==mile)
		{
			candidate=i;
			break;
		}
	}
	if(candidate==-1)
		// We reached the end without finding a zone, so pick one from the beginning
		return PickZone(mile);
	return candidate;
}

// Always use ACS_ExecuteAlways to call this script, and it will queue up messages if needed
script S_MESSAGE(int wave)
{
	Setup();
	int ticketNumber=msgEndOfLine++;
	while(ticketNumber !=msgCurTurn)
		delay(1);
	int curFace;
	for(int i=0; i<RadioMessagesUsed; i++)
	{
		if(RadioMessages[i][0]==wave)
		{
			if(RadioName[ RadioMessages[i][1] ]==RADIO_RANDOM)
				curFace=randomRadioFace;
			else
				curFace=RadioName[i] - 1;

			// Show Mug shot of speaker
			// SetFont(RadioData[curFace][1]);
			// HudmessageBold(s:"A"; HUDMSG_PLAIN,RadioMugHID,-1,32.1,100.0,4.5);
			SetHudSize(800,600,1);
			// Show his name
			SetFont("ConFont");
			HudmessageBold(s:RadioData[curFace][0]; HUDMSG_PLAIN,RadioNameHID,CR_WHITE,44.1,80.1,4.5);
			// Show message text
			HudmessageBold(s:RadioMessages[i][2]; HUDMSG_TYPEON|HUDMSG_LOG,RadioTextHID,CR_GOLD,44.1,110.1,99.0,0.03,0.5);
			// Show the dialog box
			SetFont("DIALOGBX");
			HudmessageBold(s:"A"; HUDMSG_FADEINOUT,RadioBoxHID,CR_WHITE,32.1,134.0,4.35,0.15,0.0);
			AmbientSound("misc/chat",64);
			delay((4.5*35)/1.0);
		}
	}
	HudmessageBold(s:""; HUDMSG_PLAIN,RadioTextHID,CR_UNTRANSLATED,0.0,0.0,0.1);
	delay((0.7*35)/1.0); // Wait about half a second before letting any queued messages go to avoid a quick flicker
	msgCurTurn++;	// Let next message in line go
}

script "EnterScript" ENTER
{
	if(!CheckInventory("StartingToken"))	//Gives 3 lives and 300 coins to any playerclass
	{
		GiveInventory("LifeItem",3);
		GiveInventory("CoinItem",300);
		GiveInventory("StartingToken",1);
	}
	Thing_ChangeTID(0,PLAYER_TID_START + PlayerNumber());
	highestPlayerNumber=max(PlayerNumber(),highestPlayerNumber);
	// Trackers(for SBARINFO)
	TakeInventory("JailTracker",INT_MAX);
	TakeInventory("JailTrackerAllPlayers",INT_MAX);
	TakeInventory("HUDCredits",INT_MAX);
	TakeInventory("ThrustDummy",INT_MAX);
	// Bugs
	TakeInventory("PowerQuadDamage",INT_MAX);
	TakeInventory("PowerTimeFreezer",INT_MAX);
	TakeInventory("PowerScannerSustain",INT_MAX);

	if(PlayersAreLate)
	{
		if(PrisonSpot)
		{
			Print(s:"You are late to the game!");
			GiveInventory("JailTracker",1);
			UpdateJailTrackers();
			While(! Teleport_NoFog(PrisonSpot,true,0))
				delay(5);
			GiveInventory("CoinItem",1250);
			TakeInventory("LifeItem",9);
		}
		else UpdateJailTrackers();
	}
	UpdateWaveTrackers();
	UpdateTime();

	// We need to reset the player's speed just in case he ended a map with it modified.
	// (The thrusting script can modify it.)
	SetActorProperty(0,APROP_Speed,1.0);
	if(BriefActive)
		SetPlayerProperty(1,true,PROP_TOTALLYFROZEN);
	else
		SetPlayerProperty(0,false,PROP_TOTALLYFROZEN);
	delay(1);

	// Pause this script while Brief is active, so that way the player gets his gun
	// after it's finished. The Briefing scripts handle unfreezing the player.
	while(BriefNoGun)
		delay(1);

	if(GetLevelInfo(LEVELINFO_LEVELNUM)==999)
	{
		ACS_ExecuteAlways(S_HUD_COINS,0,0);
		//	GiveInventory("HUDCredits",1);	// Enables intermission hud parts
		//Give custom players a pass on this next part
		if(CheckActorClass(0,"StrongholdPlayer"))
		{
			GiveInventory("StrongholdShrinkFist",1);
			SetWeapon("StrongholdShrinkFist");
			while(true)
			{
				delay(35);	// Placed at beginning of loop, so that there is no chance this
							// becomes a runaway script
				if(!CheckWeapon("StrongholdShrinkFist"))
				{
					Print(s:"You're lucky you didn't get shot for holding a loaded weapon here!");
					GiveInventory("StrongholdShrinkFist",1);
					SetWeapon("StrongholdShrinkFist");
					restart;	// Clear inventory again
				}
			}
		}
	}
}

script S_LATEPLAYERS OPEN
{
	delay(LatePlayersDelay);
	PlayersAreLate++;
}

// Displays amount of user's coins at top of screen in the intermap
script S_HUD_COINS(void)
{
	sethudsize(640,480,0);
	setfont("HUDINT");
	HudMessage(s:"a"; HUDMSG_PLAIN,MoneyBarHID,CR_UNTRANSLATED,320.0,240.0,0.0);
	SetFont("SMALLFONT");
	int lastCoinAmount=-1;
	while(true)
	{
		if(CheckInventory("CoinItem") !=lastCoinAmount)
		{
			HudMessage(s:"\cGCredits\n$",i:CheckInventory("CoinItem");
				HUDMSG_PLAIN,MoneyCountHID,CR_UNTRANSLATED,570.0,30.0,0.0);
			lastCoinAmount=CheckInventory("CoinItem");
		}
		delay(25);
	}
}

// If player has zero lives, alert him, then send to jail
// For if a player drops his last life while alive (respawn script handles spawning without a life)
script "LivesWatch" ENTER
{
	//Prevent the message from being printed if the game is just beginning
	delay(1);
	// If the player has a JailTracker, then the respawn script is handling this, or he's in jail already
	if(!CheckInventory("LifeItem")&&!CheckInventory("JailTracker")&&CheckInventory("Health")>0)
	{
		if(PrisonSpot)
		{
			Print(s:"Warning: You are out of lives!\n\nYou are about to be teleported to jail");
			delay(35*10);	// Give the player a moment, so he can pick the life back
							// up if he accidentally dropped it.
			ACS_ExecuteAlways(S_RESPAWN,0,0);
		}
		else
		{
			Print(s:"Warning: You are out of lives!\n\nBut this map doesn't use a Jail, so you're free for now.");
			delay(20*35); // Wait a bit so that this message isn't constant
		}
	}
	delay(5);
	restart;
}

// Player loses a life
script 671 DEATH
{
	TakeInventory("ThrustDummy",1);
	if(GameActive&&GetLevelInfo(LEVELINFO_LEVELNUM)!=999)
		TakeInventory("LifeItem",1);
}

script S_RESPAWN RESPAWN
{
	// Make sure our old dead body doesn't still have our tid
	Thing_ChangeTid(PLAYER_TID_START+PlayerNumber(),0);
	Thing_ChangeTid(0,PLAYER_TID_START+PlayerNumber());
	TakeInventory("JailTracker",INT_MAX);
	TakeInventory("ThrustDummy",1);
	if(CheckInventory("LifeItem")==0)
	{
		if(PrisonSpot)
		{
			Print(s:"You are out of lives!");
			GiveInventory("JailTracker",1);
			UpdateJailTrackers();
			While(! Teleport_NoFog(PrisonSpot,true,0))
				delay(5);
		}
	}
	else
		UpdateJailTrackers();
	SetActorProperty(0,APROP_Speed,1.0);
	SetPlayerProperty(0,BriefActive,PROP_TOTALLYFROZEN);
}

script S_DISCONNECT(int gone) DISCONNECT
{
	UpdateJailTrackers();
}

function void SetJailTeleporter(bool setting)
{
	jailTeleporter=setting;
	if(jailTeleporter)
	{
		thing_deactivate(TeleporterOffLight);	// Dynamic Lights
		thing_activate(TeleporterOnLight);
		setlinetexture(PrisonTeleporterLineId,SIDE_FRONT,TEXTURE_MIDDLE,"TELEPTY1");
	}
	else
	{
		thing_activate(TeleporterOffLight);
		thing_deactivate(TeleporterOnLight);
		setlinetexture(PrisonTeleporterLineId,SIDE_FRONT,TEXTURE_MIDDLE,"TELEPTX1");
	}
}

script S_JAIL_LEAVE(int angle)
{
	if(jailTeleporter)
	{
		if(Teleport(PrisonExit,0,0))
		{
			SetJailTeleporter(FALSE);
			TakeInventory("JailTracker",1);
			GiveInventory("LifeItem",1);
			UpdateJailTrackers();
		}
		else
		{
			ThrustThing(angle,30,0);
			Print(s:"Teleporter blocked. Try again");
		}
	}
	else
	{
		ThrustThing(angle,30,0);
		Print(s:"Teleporter is off");
	}
}

script S_JAIL_GIVEUP(void)
{
	if(CheckInventory("JailTrackerAllPlayers")==PlayerCount())
		Exit_Normal(ExitPos);
	else
	{
		Print(s:"\cGThere are still \cCplayers \cGon the battlefield!");
		if(PrisonExitThrustAngle==-1)
			ACS_ExecuteAlways(S_G_THRUST,0,0);
		else
			ThrustThing(PrisonExitThrustAngle,30,0);
	}
}

script S_JAIL_OPEN(void) // This is the script called if you use a LifeItem
{
	// If the player is in jail, he can use his last LifeItem.
	// (...This is impossible to do without cheats.)
	if(CheckInventory("LifeItem")==1&&!CheckInventory("JailTracker"))
	{
		Print(s:"You can't use your last Life to open the jail teleporter!");
		SetResultValue(FALSE);
	}
	else if(PrisonTeleporterLineId)
	{
		if(CheckInventory("JailTrackerAllPlayers"))
		{
			if(! jailTeleporter)
			{
				PrintBold(s:"Prison Teleporter Opened");
				SetJailTeleporter(TRUE);
				SetResultValue(TRUE);
			}
			else
			{
				Print(s:"Prison Teleporter already Open");
				SetResultValue(FALSE);
			}
		}
		else
		{
			Print(s:"No players are in jail!");
			SetResultValue(FALSE);
		}
	}
	else
	{
		Print(s:"Not usable here!\n\nThis map does not have a jail teleporter to open.");
		SetResultValue(FALSE);
	}
}

script S_BRIEF_MAIN(void)
{
	ACS_Execute(S_BRIEF_ANIMATE,0,0);
	BriefActive=TRUE;
	BriefNoGun=TRUE;
	SetPlayerProperty(1,TRUE,PROP_TOTALLYFROZEN);
	SetFont("BLACK");
	SetHudSize(4,4,0);
	HudMessageBold(s:"a"; HUDMSG_PLAIN,FadeOutHID,CR_UNTRANSLATED,2.0,2.0,0.0);
	SetHudSize(640,480,0);
	SetFont(BriefBackground);
	HudMessageBold(s:"a"; HUDMSG_PLAIN,BriefBGHID,0,320.0,240.0,0.0);
	SetHudSize(640,480,1);
	if(BriefSkippable)
	{
		SetFont("SMALLFONT");
		HudMessageBold(s:"\cCHit \cG<Use> \cCto skip the introduction";
			HUDMSG_FADEINOUT,BriefSkipHID,0,320.0,465.0,2.0,6.0,2.0);
	}
	if(BriefScript)
		ACS_ExecuteWait(BriefScript,0,0);
	ACS_Execute(S_BRIEF_END,0,0);
}

script S_BRIEF_ANIMATE(void)
{
	sethudsize(640,480,1);
	setfont("BIGFONT");
	hudmessagebold(s:"\cGInstructor Lt. Carmack:\n";HUDMSG_PLAIN,BriefNameHID,CR_UNTRANSLATED,345.0,310.0,0.0);
	while(TRUE)
	{
		if(!BriefTalking)
		{
			setfont("BRIEFTN2");
			HudMessageBold(s:"a"; HUDMSG_PLAIN,BriefTalkBoxHID,0,BriefTalkBoxX,BriefTalkBoxY,0.0);
			delay(25);
			while(!BriefTalking)
				delay(1);
		}
		else
		{
			setfont("BRIEFTN2");
			HudMessageBold(s:"a"; HUDMSG_PLAIN,BriefTalkBoxHID,0,BriefTalkBoxX,BriefTalkBoxY,2.0);
			delay(10);
			setfont("BRIEFTY2");
			HudMessageBold(s:"a"; HUDMSG_PLAIN,BriefTalkBoxHID,0,BriefTalkBoxX,BriefTalkBoxY,2.0);
			delay(10);
			setfont("BRIEFTY1");
			HudMessageBold(s:"a"; HUDMSG_PLAIN,BriefTalkBoxHID,0,BriefTalkBoxX,BriefTalkBoxY,2.0);
			delay(10);
			setfont("BRIEFTY2");
			HudMessageBold(s:"a"; HUDMSG_PLAIN,BriefTalkBoxHID,0,BriefTalkBoxX,BriefTalkBoxY,2.0);
			delay(10);
			setfont("BRIEFTN2");
			HudMessageBold(s:"a"; HUDMSG_PLAIN,BriefTalkBoxHID,0,BriefTalkBoxX,BriefTalkBoxY,2.0);
			delay(10);
			setfont("BRIEFTY1");
			HudMessageBold(s:"a"; HUDMSG_PLAIN,BriefTalkBoxHID,0,BriefTalkBoxX,BriefTalkBoxY,2.0);
			delay(10);
			setfont("BRIEFTY2");
			HudMessageBold(s:"a"; HUDMSG_PLAIN,BriefTalkBoxHID,0,BriefTalkBoxX,BriefTalkBoxY,2.0);
			delay(10);
			setfont("BRIEFTY1");
			HudMessageBold(s:"a"; HUDMSG_PLAIN,BriefTalkBoxHID,0,BriefTalkBoxX,BriefTalkBoxY,2.0);
			delay(10);
		}
	}
}

script S_BRIEF_END(void)	// #251
{
	if(!BriefActive)
		terminate;
	ACS_Terminate(S_BRIEF_MAIN,0);
	ACS_Terminate(S_BRIEF_ANIMATE,0);
	if(BriefScript)
		ACS_Terminate(BriefScript,0);
	HudMessageBold(s:""; HUDMSG_PLAIN,BriefSkipHID,CR_UNTRANSLATED,0.0,0.0,1.0); // Press use to skip
	HudMessageBold(s:""; HUDMSG_PLAIN,BriefExtraHID,CR_UNTRANSLATED,0.0,0.0,1.0); // Extra pictures
	HudMessageBold(s:""; HUDMSG_PLAIN,BriefHID,CR_UNTRANSLATED,0.0,0.0,1.0); // Message Text
	SetFont("BLACK");
	SetHudSize(4,4,0);
	HudMessageBold(s:"a"; HUDMSG_FADEOUT,FadeOutHID,CR_UNTRANSLATED,2.0,2.0,0.0,2.0);	// holdTime, outTime
	SetHudSize(640,480,0);
	SetFont(BriefBackground);
	HudMessageBold(s:"a"; HUDMSG_FADEOUT,BriefBGHID,0,320.0,240.0,0.0,2.0);
	SetHudSize(640,480,1);
	SetFont("BIGFONT");
	HudMessageBold(s:"\cGInstructor Lt. Carmack:\n";
		HUDMSG_FADEOUT,BriefNameHID,CR_UNTRANSLATED,345.0,310.0,0.0,0.5);
	SetFont("BRIEFTN2");
	HudMessageBold(s:"a"; HUDMSG_FADEOUT,BriefTalkBoxHID,0,BriefTalkBoxX,BriefTalkBoxY,0.2,0.5);
	Delay(1*35);
	BriefNoGun=FALSE;	// This lets the player spawn with his gun a bit before unfreezing
	Delay(2*35);
	BriefActive=FALSE;
	SetPlayerProperty(1,FALSE,PROP_TOTALLYFROZEN);
}

// Standard Battlefield Border Script
script S_BF_THRUST(int byte_angle,int focustid) // #254
{
	Print(s:"\cGYou must not leave the battlefield!");
//	ThrustThing(byte_angle,30,0,0);
	ACS_ExecuteAlways(S_G_THRUST,0,focustid);
}

// Generic Thrust script, no angle needed
// Optional arg, focustid: Thrust is towards it
script S_G_THRUST(int focustid)
{
	if((LineSide()==LINE_FRONT) &&(!CheckInventory("ThrustDummy")))
	{
		GiveInventory("ThrustDummy",1);
		int oldx=GetActorX(0),oldy=GetActorY(0),oldz=GetActorZ(0),oldSpeed=GetActorProperty(0,APROP_Speed);
		SetActorProperty(0,APROP_Speed,0.0);
		int byte_angle;
		if(!focustid)
		{
			delay(1);
			int newx=GetActorX(0),newy=GetActorY(0);
			// Gets angle of opposite of current momentum
			byte_angle=VectorAngle(oldx-newx,oldy-newy) >> 8;
			SetActorPosition(0,oldx,oldy,oldz,false);
		}
		else
		{
			int focusx=GetActorX(focustid),focusy=GetActorY(focustid);
			byte_angle=VectorAngle(focusx-oldx,focusy-oldy) >> 8;
		}
		Thing_Stop(0);
		int i;
		do
		{
			ThrustThing(byte_angle,max(min(i*3,30),5),0,0);
			if((i%10)==0)
			{
				if(i>35*13)
					Thing_Damage(0,100000,MOD_UNKNOWN);
				else if(i>35*5)
					Thing_Damage(0,20,MOD_UNKNOWN);
			}
			i++;
			delay(1);
		}
		while((CheckInventory("ThrustDummy")>0) &&(GetActorProperty(0,APROP_Health)>0));
			SetActorProperty(0,APROP_Speed,oldSpeed);
	}
	if(LineSide()==LINE_BACK)
		TakeInventory("ThrustDummy",1);
}

// Does some sanity checks on the map
script S_DEBUG(int wavemanip /*void*/) // 'puke 930'
{
	if(wavemanip)
	{
		F_CallNextWave=wavemanip;
		terminate;
	}
	PrintBold(s:"Debug script starting");
	int i,j,count,errors;
	for(i=0; i<WeaponSpotsUsed; i++)
	{
		count=ThingCount(T_NONE,WeaponSpots[i]);
		if(count !=1)
			PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
				s:" weapon spots with tid ",d:WeaponSpots[i]);
	}
	for(i=0; i<MedicSpotsUsed; i++)
	{
		count=ThingCount(T_NONE,MedicSpots[i]);
		if(count !=1)
			PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
				s:" medic spots with tid ",d:MedicSpots[i]);
	}
	for(i=0; i<AmmoSpotsUsed; i++)
	{
		count=ThingCount(T_NONE,AmmoSpots[i]);
		if(count !=1)
			PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
				s:" ammo spots with tid ",d:AmmoSpots[i]);
	}
	for(i=0; i<PowerupSpotsUsed; i++)
	{
		count=ThingCount(T_NONE,PowerupSpots[i]);
		if(count !=1)
			PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
				s:" powerup spots with tid ",d:PowerupSpots[i]);
	}
	for(i=0; i<ZoneDataUsed; i++)
	{
		for(j=8; j<=9; j++)
		{
			count=ThingCount(T_NONE,ZoneData[i][j]);
			if(count !=1)
				PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
					s:" zone mapspots with tid ",d:ZoneData[i][j]);
		}
	}
	// A mapspot with tid 900 or 901 used to be used as "TEST_TID" but is now useless.
	// Removing it helps remove some clutter.
	for(i=900; i<=901; i++)
	{
		count=ThingCount(T_NONE,i);
		if(count > 0)
			PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
				s:" extra mapspots with tid ",d:i);
	}
	if(PrisonSpot)
	{
		count=ThingCount(T_NONE,PrisonSpot);
		if(count < 8)
			PrintBold(s:"Error ",d:++errors,s:": There are only ",d:count,
				s:" prison spots with tid ",d:PrisonSpot,s:". Suggested to have at least 8.");
		count=ThingCount(T_NONE,PrisonExit);
		if(!count)
			PrintBold(s:"Error ",d:++errors,s:": There is no PrisonExit with tid ",
				d:PrisonExit,s:". Required to have at least 1.");
		if(TeleporterOnLight)
		{
			count=ThingCount(T_NONE,TeleporterOnLight);
			if(count==0)
				PrintBold(s:"Error ",d:++errors,s:": There is no",
					s:" TeleporterOnLight expecting tid ",d:TeleporterOnLight);
		}
		if(TeleporterOffLight)
		{
			count=ThingCount(T_NONE, TeleporterOffLight);
			if(count==0)
				PrintBold(s:"Error ",d:++errors,s:": There is no",
					s:" TeleporterOffLight expecting tid ",d:TeleporterOffLight);
		}
	}
	// The HateEpicenter should be a shootable thing.
	if(HateEpicenter&&!CheckFlag(HateEpicenter,"SHOOTABLE"))
		PrintBold(s:"Error ",d:++errors,s:": There is no",
			s:" HateTarget or living HateEpicenter expecting tid ",d:HateEpicenter,
			s:".\nRemove the HateEpicenter line from the map's script if you don't want one.");
	if(BossMonster&&ThingCount(T_NONE,BossMonster) !=1)
		PrintBold(s:"Error ",d:++errors,s:": There is more or less",s:" than 1 actor with the BossMonster Tid.");
	if(errors > 0)
		PrintBold(s:"Debug script completed with ",d:errors,s:" error(s)\n\nCheck your console");
	else
		PrintBold(s:"Debug script completed with no errors");
}

// Randomizes the STR52 code if needed, and then prints the correct sequence to the screen.
script S_STR52CODEGET(void)	// Script 927
{
	// Has the code been set yet? Set a code if not
	if(!str52codeinit)
	{
		for(int i=0; i<5; i++)
			str52code[i]=random(0,9);
		str52codeinit=TRUE;
	}
	sethudsize(640,480,0);
	setFont("BigFont");
	HudMessage(d:str52code[0],s:" ",d:str52code[1],s:" ",d:str52code[2],s:" ",d:str52code[3],s:" ",d:str52code[4],s:" ";
		HUDMSG_PLAIN | HUDMSG_LOG,11,CR_WHITE,60.0,400.0,9.0);
	delay(35*8);
}

// HUD Stuff

script S_HUD OPEN clientside
{
	if(GetLevelInfo(LEVELINFO_LEVELNUM)==999)
		Terminate;
	// Launch a copy of the timer script clientside
	ACS_Execute(S_TIMER,0,0);
	SetHudSize(640,480,1);
	int aspect,adjWidth,left,right,showedPar;
	while(true)
	{
		// If set, turn off hud, and wait for the value to be toggled again
		if(getcvar("sthd_hud_disable"))
		{
			ClearHud();
			while(getcvar("sthd_hud_disable"))
				delay(1);
		}
		// Code to disable HUD when regular HUD is gone
		/*if(getcvar("screenblocks")==12)
		{
			ClearHud();
			while(getcvar("screenblocks")==12)
				delay(1);
		}*/
		aspect=getaspectratio();
		adjWidth=aspect * 480;
		left=fround((640.0-adjWidth)/2);
		right=fround((adjWidth+640.0)/2);
		SetFont("HUDLEFT");
		HudMessageBold(s:"A"; HUDMSG_PLAIN,HUDLeftHID,CR_UNTRANSLATED,left+0.1,0.1,0.0);
		SetFont("HUDRIGHT");
		HudMessageBold(s:"A"; HUDMSG_PLAIN,HUDRightHID,CR_UNTRANSLATED,right+0.2,0.1,0.0);
		SetFont("BIGFONT");
		HudMessageBold(d:GetLevelInfo(LEVELINFO_LEVELNUM); HUDMSG_PLAIN,HUDLevelHID,CR_RED,left+83.0,15.0,0.0);
		// Show Par Time
		if(parTimeMode !=0)
		{
			// Time
			HudMessageBold(d:parTimeMinutes,s:":",s:parTimeSecondsSpace,d:parTimeSeconds;
				HUDMSG_PLAIN,HUDParTimeHID,CR_DARKGRAY,right-38.0,80.0,0.0);
			// Label
			if(parTimeMode==1)
				HudMessageBold(s:"Par Time";
					HUDMSG_PLAIN,HUDParTimeLabelHID,CR_DARKGRAY,right-70.0+0.2,80.0,0.0);
			else if(parTimeMode==2)
				HudMessageBold(s:"Best Time";
					HUDMSG_PLAIN,HUDParTimeLabelHID,CR_DARKGRAY,right-70.0+0.2,80.0,0.0);
		}
		else
		{
			HudMessageBold(s:""; HUDMSG_PLAIN,HUDParTimeHID,CR_UNTRANSLATED,0.0,0.0,0.5);
			HudMessageBold(s:""; HUDMSG_PLAIN,HUDParTimeLabelHID,CR_UNTRANSLATED,0.0,0.0,0.5);
		}
		showedPar=parTimeMode;
		do
		{
			// Wave
			HudMessageBold(d:curWave; HUDMSG_PLAIN,HUDWaveHID,CR_RED,left+192.0,15.0,0.0);
			// Body count
			HudMessageBold(d:GetLevelInfo(LEVELINFO_KILLED_MONSTERS); HUDMSG_PLAIN,HUDBodyCountHID,CR_RED,right-38.0,39.0,0.0);
			// Monsters left
			HudMessageBold(d:GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)-GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
				HUDMSG_PLAIN,HUDMonstersHID,CR_RED,left+180.0,39.0,0.0);
			// Time Spent
			HudMessageBold(d:levelMinutes,s:":",s:levelSecondsSpace,d:levelSeconds;
				HUDMSG_PLAIN,HUDTimeHID,CR_RED,right-38.0,15.0,0.0);
			delay(1);
		}
		while((aspect==getaspectratio()) &&(showedPar==parTimeMode) &&(!getcvar("sthd_hud_disable")) /* &&(getcvar("screenblocks")!=12) */);
	}
}

function void clearHud(void)
{
	HudMessageBold(s:""; HUDMSG_PLAIN,HUDLeftHID,CR_UNTRANSLATED,0.0,0.0,0.5);
	HudMessageBold(s:""; HUDMSG_PLAIN,HUDRightHID,CR_UNTRANSLATED,0.0,0.0,0.5);
	HudMessageBold(s:""; HUDMSG_PLAIN,HUDLevelHID,CR_UNTRANSLATED,0.0,0.0,0.5);
	HudMessageBold(s:""; HUDMSG_PLAIN,HUDWaveHID,CR_UNTRANSLATED,0.0,0.0,0.5);
	HudMessageBold(s:""; HUDMSG_PLAIN,HUDBodyCountHID,CR_UNTRANSLATED,0.0,0.0,0.5);
	HudMessageBold(s:""; HUDMSG_PLAIN,HUDMonstersHID,CR_UNTRANSLATED,0.0,0.0,0.5);
	HudMessageBold(s:""; HUDMSG_PLAIN,HUDTimeHID,CR_UNTRANSLATED,0.0,0.0,0.5);
	HudMessageBold(s:""; HUDMSG_PLAIN,HUDParTimeHID,CR_UNTRANSLATED,0.0,0.0,0.5);
	HudMessageBold(s:""; HUDMSG_PLAIN,HUDParTimeLabelHID,CR_UNTRANSLATED,0.0,0.0,0.5);
}

script S_TIMER open
{
	if(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]!=0)
		TimeAttackMode=TRUE;
	while(TRUE)
	{
		while(TimerIsLive)
		{
			delay(1);
			levelRunningTime++;
			if(levelRunningTime % 35==0)
			{
				levelMinutes=(levelRunningTime/35)/60;
				levelSeconds=(levelRunningTime/35)%60;
				levelSecondsSpace=zerospace(levelSeconds,2);
			}
		}
		delay(1);
	}
}

function void StartTimer(void)
{
	TimerIsLive=TRUE;
	UpdateTime();
}

function void StopTimer(void)
{
	TimerIsLive=FALSE;
	UpdateTime();
}

function void UpdateWaveTrackers(void)
{
//	PrintBold(s:"UpdateWaveTrackers - Curwave=",d:Curwave);
	ACS_ExecuteAlways(S_SYNC,0,SYNC_WAVE,Curwave);
}

// Time is tricky to update, because levelRunningTime is a 4 byte integer, and
// we can only send 3 bytes at a time in a script's arguments.
function void UpdateTime(void)
{
//	PrintBold(s:"UpdateTime - levelRunningTime=",d:levelRunningTime);
//	Scripts in reverse order because they'll probably be sent together in the same
//	packet, and executed backwards by clients.
	ACS_ExecuteAlways(S_SYNC,0,SYNC_LOTIME |(TimerIsLive<<7),(levelRunningTime>>8)%256,levelRunningTime%256);
	ACS_ExecuteAlways(S_SYNC,0,SYNC_HITIME,(levelRunningTime>>24),(levelRunningTime>>16)%256);
	// Maybe not the best place for sending the par time to clients, but it ensures no clients never get it
	if(parTimeMode !=0)
		ACS_ExecuteAlways(S_SYNC,0,SYNC_PARTIME |((parTimeMode-1)<<7),parTime>>8,parTime%256);
}

// Most significant byte first
function int unpack(int byte1,int byte2,int byte3,int byte4)
{
	return(byte1<<24) +(byte2<<16) +(byte3<<8) + byte4;
}

bool hiTimeBytesReady;
int hiTimeByte1,hiTimeByte2;

script S_SYNC(int flags,int byte1,int byte2) clientside
{
//	PrintBold(s:"S_SYNC: flags=",x:flags,s:",byte1=",d:byte1,s:",byte2=",d:byte2);
	if(AllVarsLocal)
		Terminate;
	switch(flags & 0x0000007f)
	{
		case SYNC_WAVE:
			curWave=byte1;
			break;
		case SYNC_HITIME:
			hiTimeByte1=byte1;
			hiTimeByte2=byte2;
			hiTimeBytesReady=TRUE;
			break;
		case SYNC_LOTIME:
			// Wait until SYNC_HITIME call has been made
			while(!hiTimeBytesReady)
				delay(1);
			hiTimeBytesReady=FALSE;
			levelRunningTime=unpack(hiTimeByte1,hiTimeByte2,byte1,byte2);
			TimerIsLive=(flags&0x00000080)>>7;
			break;
		case SYNC_PARTIME:
			setParTime(unpack(0,0,byte1,byte2),(flags&0x00000080)>>7);
			break;
		default:
			PrintBold(s:"Error: S_SYNC called with invalid flags ",x:flags);
	}
}

// par in seconds, type=0 for "Par Time", type=1 for "Best Time"
function void setParTime(int par,int type)
{
	parTime=par;
	if(parTime > 0)
	{
		parTimeMode=type+1;
		parTimeMinutes=parTime / 60;
		parTimeSeconds=parTime % 60;
		parTimeSecondsSpace=zerospace(parTimeSeconds,2);
	}
	else
		parTimeMode=0;
}

script S_VAR_CHECK open
{
	AllVarsLocal=TRUE;
}

script S_HARD_MODE_CHECK (void)
{
	int Result;
	if(PlayerCount()>=HardScalerPlayerCount)
		Result = 1;
	SetResultValue(Result);
}

script "weatherfx" (void)
{
    SetResultValue(GetCVar("weatherfx"));
}