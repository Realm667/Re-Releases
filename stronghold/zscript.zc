version "4.2.9"

/*
 * Copyright (c) 2018-2020 AFADoomer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
**/

class StrongholdEventHandler : StaticEventHandler
{
	//===========================================================================
	// HEAT SHADER EVENTHANDLERS
	//===========================================================================
	override void RenderOverlay(RenderEvent e)
	{
		PlayerInfo p = players[consoleplayer];
		ThinkerIterator shaderIter = ThinkerIterator.Create("ShaderControl");

		ShaderControl shaderControl;

		while (shaderControl = ShaderControl(shaderIter.Next()))
		{
			if (shaderControl.Owner && shaderControl.Owner == p.mo) {
				//Console.Printf("Shader: %s", shaderControl.ShaderToControl);
				if (shaderControl.amount >= 2)
				{
					Shader.SetUniform1f(p, shaderControl.ShaderToControl, "timer", gametic + e.FracTic);
					Shader.SetUniform1f(p, shaderControl.ShaderToControl, "amount", shaderControl.amount - 1);
					Shader.SetUniform1f(p, shaderControl.ShaderToControl, "alpha", shaderControl.alpha);
					shaderControl.SetUniforms(p, e);
					Shader.SetEnabled(p, shaderControl.ShaderToControl, true);
				}
				else
				{
					Shader.SetEnabled(p, shaderControl.ShaderToControl, false);
				}
			}
		}
	}

	//===========================================================================
	// PIXEL EATER MOTIONBLUR + INVENTORY EVENTHANDLERS
	//===========================================================================
	
	int			pitch, yaw ;
	double		xtravel, ytravel ;
	
	override void PlayerEntered(PlayerEvent e)
	{
		PlayerInfo plr = players[ consoleplayer ]; //struct for mblur
		if( plr )
		{	
			xtravel = 0 ;
			ytravel = 0 ;
		}
	
		let me=PlayerPawn(players[e.PlayerNumber].mo); //struct for inventory management, this somehow overwrite plr maybe?
		DropItem drop=me.GetDropItems();
		//First, remove all weapons, except those with the UNDROPPABLE flag
		for(int i=0;i<AllActorClasses.Size();i++)
		{
			let type=AllActorClasses[i];
			if(type is "Weapon")
			{
				let weptype=(class<weapon>)(type);
				let wepitem=weapon(me.FindInventory(weptype));
				if(wepitem!=null&&!wepitem.bUNDROPPABLE)
					me.A_TakeInventory(name(weptype));
			}
		}
		//If the player has any weapons in StartItem, set them here
		//They're not supposed to come with ammo, so clear that after this
		if(drop!=null)
		{
			for(DropItem di=drop;di!=null;di=di.Next)
			{
				if(di.Name=='None')
					continue;
				let weptype=(class<weapon>)(di.Name);
				if(weptype!=null)
					me.A_SetInventory(di.Name,di.Amount);
			}
		}
		//Remove all ammo, except that with the UNDROPPABLE flag
		for(int i=0;i<AllActorClasses.Size();i++)
		{
			let type=AllActorClasses[i];
			if(type is "Ammo")
			{
				let ammotype=(class<ammo>)(type);
				let ammoitem=ammo(me.FindInventory(ammotype));
				if(ammoitem!=null&&!ammoitem.bUNDROPPABLE)
					me.A_TakeInventory(name(ammotype));
			}
		}
		//If the player has any ammo in StartItem, set it here
		if(drop!=null)
		{
			for(DropItem di=drop;di!=null;di=di.Next)
			{
				if(di.Name=='None')
					continue;
				let ammotype=(class<ammo>)(di.Name);
				if(ammotype!=null)
					me.A_SetInventory(di.Name,di.Amount);
			}
		}
	}
	
	override void WorldTick()
	{
		PlayerInfo	plr = players[ consoleplayer ];
		if( plr && plr.health > 0 && plr.mo && Cvar.GetCVar( "motionblur", plr ).GetBool() )
		{
			yaw		= plr.mo.GetPlayerInput( ModInput_Yaw );
			pitch	= -plr.mo.GetPlayerInput( ModInput_Pitch );
		}
	}
	
	override void NetworkProcess( ConsoleEvent e )
	{
		PlayerInfo plr = players[ consoleplayer ];
		if( plr && plr.mo && e.Name == "liveupdate" )
		{
			double pitchdimin	= 1. - abs( plr.mo.pitch * 1. / 90 );
			double decay		= 1. - Cvar.GetCVar( "motionblur_recovery", plr ).GetFloat() * .01 ;
			double amount		= Cvar.GetCVar( "motionblur_strength", plr ).GetFloat() * 10. / 32767 * sqrt( pitchdimin );
			xtravel				= xtravel * decay + yaw * amount * .625 ;
			ytravel				= ytravel * decay + pitch * amount ;
			
			if( Cvar.GetCVar( "motionblur_autostop", plr ).GetBool() )
			{
				double threshold = Cvar.GetCVar( "motionblur_threshold", plr ).GetFloat() * 30 ;
				double recovery2 = 1 - Cvar.GetCVar( "motionblur_recovery2", plr ).GetFloat() * .01 ;
				if( abs( yaw )		<= threshold ) xtravel *= recovery2 ;
				if( abs( pitch )	<= threshold ) ytravel *= recovery2 ;
			}
		}
	}
	
	override void UiTick()
	{
		PlayerInfo plr = players[ consoleplayer ];
		if( plr && plr.mo )
		{
			if( plr.health > 0 && Cvar.GetCVar( "motionblur", plr ).GetBool() && !plr.mo.FindInventory("isIntro") )//&& yaw && pitch )
			{
				EventHandler.SendNetworkEvent( "liveupdate" );
				
				int copies			= 1 + Cvar.GetCVar( "motionblur_samples", plr ).GetInt() ;
				double increment	= 1. / copies ;
				vector2 travel		= ( xtravel, ytravel ) / screen.getheight() ;
				
				Shader.SetUniform2f( plr, "motionblur", "steps", travel * increment );
				Shader.SetUniform1f( plr, "motionblur", "samples", copies );
				Shader.SetUniform1f( plr, "motionblur", "increment", increment );
				Shader.SetUniform1f( plr, "motionblur", "blendmode", Cvar.GetCVar( "motionblur_blendmode", plr ).GetInt() );
					
				Shader.SetEnabled( plr, "motionblur", true );
			}
			else
			{
				Shader.SetEnabled( plr, "motionblur", false );
			}
		}
	}
}

#include "zscript/StrongholdProps.zc" 	//RichardDS90/Salahmander
#include "zscript/underwater.zc"
#include "zscript/heateffect.zc"