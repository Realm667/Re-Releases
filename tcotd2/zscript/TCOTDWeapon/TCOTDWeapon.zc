// Copyright 2020 Nash Muhandes
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//===========================================================================
//
// Base weapon class for TCOTD2
//
//===========================================================================

class TCOTDWeapon : Weapon
{
	//===========================================================================
	//
	// Rotator
	//
	//===========================================================================

	struct Rotator
	{
		Vector3 result;
		Vector3 forward, right, up;

		void SetAngles(double ang, double pch, double rol = 0)
		{
			double angCos, angSin, pchCos, pchSin, rolCos, rolSin;
			angCos = cos(ang);
			angSin = sin(ang);
			pchCos = cos(pch);
			pchSin = sin(pch);
			rolCos = cos(rol);
			rolSin = sin(rol);

			forward = (angCos * pchCos, angSin * pchCos, -pchSin);
			right = (-rolSin * pchSin * angCos + -rolCos * -angSin, -rolSin * pchSin * angSin + -rolCos * angCos, -rolSin * pchCos);
			up = (rolCos * pchSin * angCos + -rolSin * -angsin, rolCos * pchSin * angSin + -rolSin * angCos, rolCos * pchCos);
		}

		void Rotate(double ang, double pch = 0)
		{
			result = (forward + tan(ang) * right + tan(pch) * up).Unit();
		}

		void RotateCone(double ang, double pch = 0, double rol = 0)
		{
			double theta = frandom[rnd_rotator](0, 360);

			result = (forward + tan(ang * cos(theta)) * right + tan(pch * sin(theta)) * up).Unit();
		}

		Vector2 GetAngles(void)
		{
			return (atan2(result.Y, result.X), -asin(result.Z));
		}
	}

	//===========================================================================
	//
	// Fire3DBullets
	// Literally a copy of the built-in FireBullets but with changes to
	// the angle and pitch calculation
	//
	//===========================================================================

	action void Fire3DBullets(double spread_xy, double spread_z, int numbullets, int damageperbullet, class<Actor> pufftype = "BulletPuff", int flags = 1, double range = 0, class<Actor> missile = null, double Spawnheight = 32, double Spawnofs_xy = 0)
	{
		let player = player;
		if (!player) return;

		let pawn = PlayerPawn(self);
		let weapon = player.ReadyWeapon;

		int i;
		double bangle;
		double bslope = 0.;
		int laflags = (flags & FBF_NORANDOMPUFFZ)? LAF_NORANDOMPUFFZ : 0;

		if ((flags & FBF_USEAMMO) && weapon &&  stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weapon.DepleteAmmo(weapon.bAltFire, true))
				return;	// out of ammo
		}

		if (range == 0)	range = PLAYERMISSILERANGE;

		if (!(flags & FBF_NOFLASH)) pawn.PlayAttacking2 ();

		// [Nash] only changes here are the away the angles are calculated
		Rotator r;
		r.SetAngles(Angle, Pitch, Roll);
		if (flags & FBF_EXPLICITANGLE)
			r.Rotate(spread_xy, spread_z);
		else
			r.Rotate(frandom(-spread_xy, spread_xy), frandom(-spread_z, spread_z));
		Vector2 bangles = r.GetAngles();

		if (!(flags & FBF_NOPITCH)) bslope = bangles.Y;
		bangle = bangles.X;

		if (pufftype == NULL) pufftype = 'BulletPuff';

		if (weapon != NULL)
		{
			A_StartSound(weapon.AttackSound, CHAN_WEAPON);
		}

		if ((numbullets == 1 && !player.refire) || numbullets == 0)
		{
			int damage = damageperbullet;

			if (!(flags & FBF_NORANDOM))
				damage *= random[cabullet](1, 3);

			let puff = LineAttack(bangle, range, bslope, damage, 'Hitscan', pufftype, laflags);

			if (missile != null)
			{
				bool temp = false;
				double ang = Angle - 90;
				Vector2 ofs = AngleToVector(ang, Spawnofs_xy);
				Actor proj = SpawnPlayerMissile(missile, bangle, ofs.X, ofs.Y, Spawnheight);
				if (proj)
				{
					if (!puff)
					{
						temp = true;
						puff = LineAttack(bangle, range, bslope, 0, 'Hitscan', pufftype, laflags | LAF_NOINTERACT);
					}
					AimBulletMissile(proj, puff, flags, temp, false);
				}
			}
		}
		else
		{
			if (numbullets < 0)
				numbullets = 1;
			for (i = 0; i < numbullets; i++)
			{
				double pangle = bangle;
				double slope = bslope;

				if (flags & FBF_EXPLICITANGLE)
				{
					pangle += spread_xy;
					slope += spread_z;
				}
				else
				{
					pangle += spread_xy * Random2[cabullet]() / 255.;
					slope += spread_z * Random2[cabullet]() / 255.;
				}

				int damage = damageperbullet;

				if (!(flags & FBF_NORANDOM))
					damage *= random[cabullet](1, 3);

				let puff = LineAttack(pangle, range, slope, damage, 'Hitscan', pufftype, laflags);

				if (missile != null)
				{
					bool temp = false;
					double ang = Angle - 90;
					Vector2 ofs = AngleToVector(ang, Spawnofs_xy);
					Actor proj = SpawnPlayerMissile(missile, bangle, ofs.X, ofs.Y, Spawnheight);
					if (proj)
					{
						if (!puff)
						{
							temp = true;
							puff = LineAttack(bangle, range, bslope, 0, 'Hitscan', pufftype, laflags | LAF_NOINTERACT);
						}
						AimBulletMissile(proj, puff, flags, temp, false);
					}
				}
			}
		}
	}
}
