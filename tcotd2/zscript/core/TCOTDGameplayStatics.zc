/*
* TCOTD2 Game Code
* Copyright (C) 2020 - 2023  Nash Muhandes
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//===========================================================================
//
// TCOTDGameplayStatics
//
//===========================================================================

class TCOTDGameplayStatics play
{
	static bool IsOnFloor(Actor self)
	{
		if (self is "PlayerPawn")
			return PlayerPawn(self).player.onground;
		return self.Pos.Z <= self.FloorZ || self.bOnMObj || self.bMBFBouncer;
	}

	static bool IsCrouching(PlayerPawn self)
	{
		if (!self.player)
			return false;
		double ch = double((self.player.mo.ViewHeight / 2));
		return self.GetCameraHeight() <= ch;
	}

	static double GetVelocity(Actor self, bool xyOnly = false)
	{
		if (xyOnly)
			return self.Vel.XY.Length();
		return self.Vel.Length();
	}

	static void DestroyActors(class<Actor> cls)
	{
		ThinkerIterator it = ThinkerIterator.Create(cls);
		Actor mo;
		while (mo = Actor(it.Next()))
		{
			mo.Destroy();
		}
	}

	static void GiveItemToAllPlayers(class<Inventory> cls)
	{
		if (!cls)
			return;

		if (!TCOTDGameplayStatics.IsCoop())
			return;


		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i] && players[i].mo && !players[i].mo.CountInv(cls))
				players[i].mo.GiveInventory(cls, 1);
		}
	}

	static void TakeItemFromAllPlayers(String clsName)
	{
		class<Inventory> cls = clsName;
		if (!cls)
			return;

		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i] && players[i].mo && players[i].mo.CountInv(cls))
				players[i].mo.TakeInventory(cls, int.max);
		}
	}

	static int SeedFromLevelChecksum(void)
	{
		String checksum = Level.GetChecksum();

		// should be always 32 for MD5 checksum
		int length = checksum.Length();

		int seed = 0;

		for (int i = 0; i < length; ++i)
		{
			seed ^= checksum.ByteAt(i) << 8 * (i % 4);
		}

		return seed;
	}

	clearscope static bool IsConsoleVisible(void)
	{
		return (!multiplayer && (ConsoleState == c_down || ConsoleState == c_falling));
	}

	clearscope static bool IsSkillNormal(void)
	{
		return (skill == 0);
	}

	clearscope static bool IsSkillHard(void)
	{
		return (skill == 1);
	}

	clearscope static bool IsSkillNightmare(void)
	{
		return (skill >= 2);
	}

	clearscope static bool IsCoop(void)
	{
		return (multiplayer && !deathmatch);
	}

	clearscope static bool IsDeathmatch(void)
	{
		return (multiplayer && deathmatch);
	}

	clearscope static bool IsTitleMap(void)
	{
		return Level.levelnum == 0x7FFFFFFF;
	}

	/*
	clearscope static bool IsStartMap(void)
	{
		return Level.levelnum == 0x7FFFFFFE;
	}

	clearscope static bool IsPlayableMap(void)
	{
		return !IsTitleMap() && !IsStartMap();
	}
	*/

	/*
	static void CloseAutomap(void)
	{
		if (Level.time > 2)
		{
			Level.StartIntermission("Automap_Hack", FSTATE_InLevel);
		}
	}
	*/

	static ui bool IsKeyForCommand(int keyScan, String cmd)
	{
		Array<int> mapkeys;
		Bindings.GetAllKeysForCommand(mapkeys, cmd);
		return (mapkeys.Find(KeyScan) != mapkeys.Size());
	}
}
